{
  "version": 3,
  "sources": ["../src/util/ast.js", "../src/rules/no-empty-effect.js", "../src/rules/no-adjust-state-on-prop-change.js", "../src/rules/no-reset-all-state-on-prop-change.js", "../src/rules/no-event-handler.js", "../src/rules/no-pass-live-state-to-parent.js", "../src/rules/no-initialize-state.js", "../src/rules/no-chain-state-updates.js", "../src/rules/no-derived-state.js", "../src/rules/no-pass-data-to-parent.js", "../src/rules/no-manage-parent.js", "../src/rules/no-pass-ref-to-parent.js", "../src/index.js", "../src/index.cjs"],
  "sourcesContent": ["import { findVariable } from \"eslint-utils\";\n\n/**\n * @import {Scope} from 'eslint'\n * @import {Rule} from 'eslint'\n * @import {AST} from 'eslint'\n */\n\nexport const isReactFunctionalComponent = (node) =>\n  (node.type === \"FunctionDeclaration\" ||\n    (node.type === \"VariableDeclarator\" &&\n      (node.init.type === \"ArrowFunctionExpression\" ||\n        node.init.type === \"CallExpression\"))) &&\n  node.id.type === \"Identifier\" &&\n  node.id.name[0].toUpperCase() === node.id.name[0];\n\n// NOTE: Returns false for known pure HOCs -- `memo` and `forwardRef`.\n// Basically this is meant to detect custom HOCs that may have side effects, particularly when using their props.\n// TODO: Will not detect when they define the component normally and then export it wrapped in the HOC.\n// e.g. `const MyComponent = (props) => {...}; export default memo(MyComponent);`\nexport const isReactFunctionalHOC = (node) =>\n  node.type === \"VariableDeclarator\" &&\n  node.init &&\n  node.init.type === \"CallExpression\" &&\n  node.init.callee.type === \"Identifier\" &&\n  ![\"memo\", \"forwardRef\"].includes(node.init.callee.name) &&\n  node.init.arguments.length > 0 &&\n  (node.init.arguments[0].type === \"ArrowFunctionExpression\" ||\n    node.init.arguments[0].type === \"FunctionExpression\") &&\n  node.id.type === \"Identifier\" &&\n  node.id.name[0].toUpperCase() === node.id.name[0];\n\nexport const isCustomHook = (node) =>\n  (node.type === \"FunctionDeclaration\" ||\n    (node.type === \"VariableDeclarator\" &&\n      node.init &&\n      (node.init.type === \"ArrowFunctionExpression\" ||\n        node.init.type === \"FunctionExpression\"))) &&\n  node.id.type === \"Identifier\" &&\n  node.id.name.startsWith(\"use\") &&\n  node.id.name[3] === node.id.name[3].toUpperCase();\n\nexport const isUseState = (node) =>\n  node.type === \"VariableDeclarator\" &&\n  node.init &&\n  node.init.type === \"CallExpression\" &&\n  node.init.callee.name === \"useState\" &&\n  node.id.type === \"ArrayPattern\" &&\n  // Not sure its usecase, but may just have the setter\n  (node.id.elements.length === 1 || node.id.elements.length === 2) &&\n  node.id.elements.every((el) => {\n    // Apparently skipping the state element is a valid use.\n    // I suppose technically the state can still be read via setter callback.\n    return !el || el.type === \"Identifier\";\n  });\n\n// While it *could* be an anti-pattern or unnecessary, effects *are* meant to synchronize systems.\n// So we presume that a \"subscription effect\" is usually valid, or at least may be more readable.\n// TODO: We might be able to use this more granularly, e.g. ignore state setters inside a subscription effect,\n// instead of ignoring the whole effect...? But it'd have to be more complicated, like also ignore the same state setters called in the body.\nexport const hasCleanup = (node) => {\n  const effectFn = node.arguments[0];\n  return (\n    (effectFn.type === \"ArrowFunctionExpression\" ||\n      effectFn.type === \"FunctionExpression\") &&\n    effectFn.body.type === \"BlockStatement\" &&\n    effectFn.body.body.some(\n      (stmt) => stmt.type === \"ReturnStatement\" && stmt.argument,\n    )\n  );\n};\n\nexport const isPropDef = (def) => {\n  const declaringNode =\n    def.node.type === \"ArrowFunctionExpression\"\n      ? def.node.parent.type === \"CallExpression\"\n        ? def.node.parent.parent\n        : def.node.parent\n      : def.node;\n  return (\n    def.type === \"Parameter\" &&\n    ((isReactFunctionalComponent(declaringNode) &&\n      !isReactFunctionalHOC(declaringNode)) ||\n      isCustomHook(declaringNode))\n  );\n};\n\nexport const isUseRef = (node) =>\n  node.type === \"VariableDeclarator\" &&\n  node.init &&\n  node.init.type === \"CallExpression\" &&\n  node.init.callee.name === \"useRef\" &&\n  node.id.type === \"Identifier\";\n\n// NOTE: Does not include `useLayoutEffect`.\n// When used correctly, it interacts with the DOM = external system = (probably) valid effect.\n// When used incorrectly, it's probably too difficult to accurately analyze anyway.\nexport const isUseEffect = (node) =>\n  node.type === \"CallExpression\" &&\n  ((node.callee.type === \"Identifier\" && node.callee.name === \"useEffect\") ||\n    (node.callee.type === \"MemberExpression\" &&\n      node.callee.object.name === \"React\" &&\n      node.callee.property.name === \"useEffect\"));\n\n// NOTE: When `MemberExpression` (even nested ones), a `Reference` is only the root object, not the function.\nexport const getEffectFnRefs = (context, node) => {\n  const effectFn = node.arguments[0];\n  if (\n    effectFn?.type !== \"ArrowFunctionExpression\" &&\n    effectFn?.type !== \"FunctionExpression\"\n  ) {\n    return undefined;\n  }\n\n  return getDownstreamRefs(context, effectFn);\n};\n\nexport function getEffectDepsRefs(context, node) {\n  const depsArr = node.arguments[1];\n  if (depsArr?.type !== \"ArrayExpression\") {\n    return undefined;\n  }\n\n  return getDownstreamRefs(context, depsArr);\n}\n\n// NOTE: These return true for MemberExpressions *on* state, like `list.concat()`.\n// Arguably preferable, as mutating the state is functionally the same as calling the setter.\n// (Even though that is not recommended and should be prevented by a different rule).\n// And in the case of a prop, we can't differentiate state mutations from callbacks anyway.\nexport const isStateSetter = (context, ref) =>\n  getCallExpr(ref) !== undefined &&\n  getUpstreamRefs(context, ref).some((ref) => isState(ref));\nexport const isPropCallback = (context, ref) =>\n  getCallExpr(ref) !== undefined &&\n  getUpstreamRefs(context, ref).some((ref) => isProp(ref));\nexport const isRefCall = (context, ref) =>\n  getCallExpr(ref) !== undefined &&\n  getUpstreamRefs(context, ref).some((ref) => isRef(ref));\n\n// NOTE: Global variables (like `JSON` in `JSON.stringify()`) have an empty `defs`; fortunately `[].some() === false`.\n// Also, I'm not sure so far when `defs.length > 1`... haven't seen it with shadowed variables or even redeclared variables with `var`.\nexport const isState = (ref) =>\n  ref.resolved.defs.some((def) => isUseState(def.node));\n// Returns false for props of HOCs like `withRouter` because they usually have side effects.\nexport const isProp = (ref) => ref.resolved.defs.some((def) => isPropDef(def));\nexport const isRef = (ref) =>\n  ref.resolved.defs.some((def) => isUseRef(def.node));\n\n// TODO: Surely can be simplified/re-use other functions.\n// Needs a better API too so we can more easily get names etc. for messages.\nexport const getUseStateNode = (context, ref) => {\n  return getUpstreamRefs(context, ref)\n    .map((ref) => ref.resolved)\n    .find((variable) => variable.defs.some((def) => isUseState(def.node)))\n    ?.defs.find((def) => isUseState(def.node))?.node;\n};\n\n/**\n * Walks up the AST until a `useEffect` call, returning `false` if never found, or finds any of the following on the way:\n * - An async function\n * - A function declaration, which may be called at an arbitrary later time\n * - A function passed as a callback to another function or `new` - event handler, `setTimeout`, `Promise.then()` `new ResizeObserver()`, etc.\n *\n * Otherwise returns `true`.\n *\n * Inspired by https://eslint-react.xyz/docs/rules/hooks-extra-no-direct-set-state-in-use-effect\n */\nexport const isImmediateCall = (node) => {\n  if (!node.parent) {\n    // Reached the top of the program without finding a `useEffect`\n    return false;\n  } else if (isUseEffect(node.parent)) {\n    return true;\n  } else if (\n    // Obviously not immediate if async. I think this never occurs in isolation from the below conditions? But just in case for now.\n    node.async ||\n    // Inside a named or anonymous function that may be called later, either as a callback or by the developer.\n    // Note while we return false for *this* call, we may still return true for a call to the function containing this call.\n    node.type === \"FunctionDeclaration\" ||\n    node.type === \"FunctionExpression\" ||\n    node.type === \"ArrowFunctionExpression\"\n  ) {\n    return false;\n  } else {\n    // Keep going up\n    return isImmediateCall(node.parent);\n  }\n};\n\n/**\n * @param {Rule.RuleContext} context\n * @param {Scope.Reference} ref\n *\n * @returns {Scope.Reference[]}\n */\nexport const getUpstreamRefs = (context, ref, visited = new Set()) => {\n  if (visited.has(ref)) {\n    return [];\n  } else if (!ref.resolved) {\n    // I think this only happens when:\n    // 1. Import statement is missing\n    // 2. ESLint globals are misconfigured\n    return [];\n  } else if (\n    // Ignore function parameters references, aside from props.\n    // They are self-contained and essentially duplicate the argument reference.\n    // Important to use `notEmptyEvery` because global variables have an empty `defs`.\n    ref.resolved.defs.notEmptyEvery(\n      (def) => def.type === \"Parameter\" && !isPropDef(def),\n    )\n  ) {\n    return [];\n  }\n\n  // TODO: Probably best to track this here but let the downstream `traverse()` handle it.\n  // Especially if we can simplify/eliminate `getDownstreamRefs()` -> `findDownstreamNodes()` from the path.\n  visited.add(ref);\n\n  const upstreamRefs = ref.resolved.defs\n    // TODO: https://github.com/NickvanDyke/eslint-plugin-react-you-might-not-need-an-effect/issues/34\n    // `init` covers for arrow functions; also needs `body` to descend into function declarations\n    // But then for function parameters (including props), `def.node.body` is the body of the function that they belong to,\n    // so we get *all* the downstream refs in it...\n    // We only want to descend when we're traversing up the function itself; no its parameters.\n    // Probably similar logic to in `getUpstreamReactVariables`.\n    .filter((def) => !!def.node.init)\n    // Stop before we get to `useState()` - we want references to the state and setter.\n    // May not be necessary if we adapt the check in `isState()`?\n    .filter((def) => !isUseState(def.node))\n    .flatMap((def) => getDownstreamRefs(context, def.node.init))\n    .flatMap((ref) => getUpstreamRefs(context, ref, visited));\n\n  // Ultimately return only leaf refs\n  return upstreamRefs.length === 0 ? [ref] : upstreamRefs;\n};\n\nexport const traverse = (context, node, visit, visited = new Set()) => {\n  if (visited.has(node)) {\n    return;\n  }\n\n  visited.add(node);\n  visit(node);\n\n  (context.sourceCode.visitorKeys[node.type] || [])\n    .map((key) => node[key])\n    // Some `visitorKeys` are optional, e.g. `IfStatement.alternate`.\n    .filter(Boolean)\n    // Can be an array, like `CallExpression.arguments`\n    .flatMap((child) => (Array.isArray(child) ? child : [child]))\n    // Can rarely be `null`, e.g. `ArrayPattern.elements[1]` when an element is skipped - `const [a, , b] = arr`\n    .filter(Boolean)\n    // Check it's a valid AST node\n    .filter((child) => typeof child.type === \"string\")\n    .forEach((child) => traverse(context, child, visit, visited));\n};\n\nexport const findDownstreamNodes = (context, topNode, type) => {\n  const nodes = [];\n  traverse(context, topNode, (node) => {\n    if (node.type === type) {\n      nodes.push(node);\n    }\n  });\n  return nodes;\n};\n\n/**\n * @param {Rule.RuleContext} context\n * @param {Rule.Node} node\n */\nexport const getDownstreamRefs = (context, node) =>\n  findDownstreamNodes(context, node, \"Identifier\")\n    .map((identifier) => getRef(context, identifier))\n    .filter(Boolean);\n\nconst getRef = (context, identifier) =>\n  findVariable(\n    context.sourceCode.getScope(identifier),\n    identifier,\n  )?.references.find((ref) => ref.identifier === identifier);\n\nexport const getCallExpr = (ref, current = ref.identifier.parent) => {\n  if (current.type === \"CallExpression\") {\n    // We've reached the top - confirm that the ref is the (eventual) callee, as opposed to an argument.\n    let node = ref.identifier;\n    while (node.parent.type === \"MemberExpression\") {\n      node = node.parent;\n    }\n\n    if (current.callee === node) {\n      return current;\n    }\n  }\n\n  if (current.type === \"MemberExpression\") {\n    return getCallExpr(ref, current.parent);\n  }\n\n  return undefined;\n};\n\nexport const isArgsAllLiterals = (context, callExpr) =>\n  callExpr.arguments\n    .flatMap((arg) => getDownstreamRefs(context, arg))\n    .flatMap((ref) => getUpstreamRefs(context, ref)).length === 0;\n", "import { isUseEffect, getEffectFnRefs } from \"../util/ast.js\";\n\n/**\n * @type {import(\"eslint\").Rule.RuleModule}\n */\nexport default {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"Disallow empty effects.\",\n    },\n    schema: [],\n    messages: {\n      avoidEmptyEffect: \"This effect is empty and could be removed.\",\n    },\n  },\n  create: (context) => ({\n    CallExpression: (node) => {\n      if (!isUseEffect(node)) return;\n\n      if (\n        node.arguments?.length === 0 ||\n        getEffectFnRefs(context, node)?.length === 0\n      ) {\n        // Hopefully it's obvious the effect can be removed.\n        // More a follow-up for once they fix/remove other issues.\n        context.report({\n          node,\n          messageId: \"avoidEmptyEffect\",\n        });\n      }\n    },\n  }),\n};\n", "import { getCallExpr, getUpstreamRefs } from \"../util/ast.js\";\nimport {\n  getEffectDepsRefs,\n  getEffectFnRefs,\n  isArgsAllLiterals,\n  isImmediateCall,\n  isProp,\n  isStateSetter,\n  isUseEffect,\n} from \"../util/ast.js\";\n\n/**\n * @type {import(\"eslint\").Rule.RuleModule}\n */\nexport default {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"Disallow adjusting state in an effect when a prop changes.\",\n      url: \"https://react.dev/learn/you-might-not-need-an-effect#adjusting-some-state-when-a-prop-changes\",\n    },\n    schema: [],\n    messages: {\n      avoidAdjustingStateWhenAPropChanges:\n        \"Avoid adjusting state when a prop changes. Instead, adjust the state directly during render, or refactor your state to avoid this need entirely.\",\n    },\n  },\n  create: (context) => ({\n    CallExpression: (node) => {\n      if (!isUseEffect(node)) return;\n      const effectFnRefs = getEffectFnRefs(context, node);\n      const depsRefs = getEffectDepsRefs(context, node);\n      if (!effectFnRefs || !depsRefs) return;\n\n      const isAllDepsProps = depsRefs\n        .flatMap((ref) => getUpstreamRefs(context, ref))\n        .notEmptyEvery((ref) => isProp(ref));\n\n      effectFnRefs\n        .filter((ref) => isStateSetter(context, ref))\n        .filter((ref) => isImmediateCall(ref.identifier))\n        .forEach((ref) => {\n          const callExpr = getCallExpr(ref);\n\n          // TODO: Flag non-literals too? e.g. I think this is the correct warning for https://github.com/getsentry/sentry/pull/100177/files#diff-cf3aceaba5cdab4553d92644581e23d54914923199d31807fe090e0d49b786caR97\n          if (isAllDepsProps && isArgsAllLiterals(context, callExpr)) {\n            context.report({\n              node: callExpr,\n              messageId: \"avoidAdjustingStateWhenAPropChanges\",\n            });\n          }\n        });\n    },\n  }),\n};\n", "import { getCallExpr, getUpstreamRefs, traverse } from \"../util/ast.js\";\nimport {\n  getEffectFnRefs,\n  getEffectDepsRefs,\n  isStateSetter,\n  isProp,\n  getUseStateNode,\n  isUseState,\n  isReactFunctionalComponent,\n  isReactFunctionalHOC,\n  isCustomHook,\n  isUseEffect,\n} from \"../util/ast.js\";\n\n/**\n * @type {import(\"eslint\").Rule.RuleModule}\n */\nexport default {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description:\n        \"Disallow resetting all state in an effect when a prop changes.\",\n      url: \"https://react.dev/learn/you-might-not-need-an-effect#resetting-all-state-when-a-prop-changes\",\n    },\n    schema: [],\n    messages: {\n      avoidResettingAllStateWhenAPropChanges:\n        'Avoid resetting all state when a prop changes. If \"{{prop}}\" is a key, pass it as `key` instead so React will reset the component.',\n    },\n  },\n  create: (context) => ({\n    CallExpression: (node) => {\n      if (!isUseEffect(node)) return;\n      const effectFnRefs = getEffectFnRefs(context, node);\n      const depsRefs = getEffectDepsRefs(context, node);\n      if (!effectFnRefs || !depsRefs) return;\n      // Skip custom hooks because they can't receive `key` like components can.\n      const containingNode = findContainingNode(node);\n      if (containingNode && isCustomHook(containingNode)) return;\n\n      const propUsedToResetAllState = findPropUsedToResetAllState(\n        context,\n        effectFnRefs,\n        depsRefs,\n        node,\n      );\n\n      if (propUsedToResetAllState) {\n        context.report({\n          node: node,\n          messageId: \"avoidResettingAllStateWhenAPropChanges\",\n          data: { prop: propUsedToResetAllState.identifier.name },\n        });\n      }\n    },\n  }),\n};\n\nconst findPropUsedToResetAllState = (\n  context,\n  effectFnRefs,\n  depsRefs,\n  useEffectNode,\n) => {\n  const stateSetterRefs = effectFnRefs.filter((ref) =>\n    isStateSetter(context, ref),\n  );\n\n  const isAllStateReset =\n    stateSetterRefs.length > 0 &&\n    stateSetterRefs.every((ref) => isSetStateToInitialValue(context, ref)) &&\n    stateSetterRefs.length ===\n      countUseStates(context, findContainingNode(useEffectNode));\n\n  return isAllStateReset\n    ? depsRefs\n        .flatMap((ref) => getUpstreamRefs(context, ref))\n        .find((ref) => isProp(ref))\n    : undefined;\n};\n\nconst isSetStateToInitialValue = (context, setterRef) => {\n  const setStateToValue = getCallExpr(setterRef).arguments[0];\n  const stateInitialValue = getUseStateNode(context, setterRef).init\n    .arguments[0];\n\n  // `useState()` (with no args) defaults to `undefined`,\n  // so ommitting the arg is equivalent to passing `undefined`.\n  // Technically this would false positive if they shadowed\n  // `undefined` in only one of the scopes (only possible via `var`),\n  // but I hope no one would do that.\n  const isUndefined = (node) => node === undefined || node.name === \"undefined\";\n  if (isUndefined(setStateToValue) && isUndefined(stateInitialValue)) {\n    return true;\n  }\n\n  // `sourceCode.getText()` returns the entire file when passed null/undefined - let's short circuit that\n  if (setStateToValue === null && stateInitialValue === null) {\n    return true;\n  } else if (\n    (setStateToValue && !stateInitialValue) ||\n    (!setStateToValue && stateInitialValue)\n  ) {\n    return false;\n  }\n\n  // TODO: This is one of the few times we compare just the immediate nodes,\n  // not upstream variables - that seems pretty complicated here?\n  // At the least, upstream functions would have to return literals for us to consider too, not just variables...\n  return (\n    context.sourceCode.getText(setStateToValue) ===\n    context.sourceCode.getText(stateInitialValue)\n  );\n};\n\nconst countUseStates = (context, componentNode) => {\n  if (!componentNode) {\n    return 0;\n  }\n\n  let count = 0;\n\n  traverse(context, componentNode, (node) => {\n    // TODO: Could optimize by not descending into nested functions/components, since hooks must be at the top level.\n    if (isUseState(node)) {\n      count++;\n    }\n  });\n\n  return count;\n};\n\n// Returns the component or custom hook that contains the `useEffect` node.\n// WARNING: Per the `isReactFunctionalComponent` etc. internals, this will return undefined for some non-idiomatic component definitions.\n// e.g. `function buildComponent(arg1, arg2) { return <div />; }`\n// Not sure we can account for that without introducing false positives, and those are rare and arguably bad practice.\nconst findContainingNode = (node) => {\n  if (!node) {\n    return undefined;\n  } else if (\n    isReactFunctionalComponent(node) ||\n    isReactFunctionalHOC(node) ||\n    isCustomHook(node)\n  ) {\n    return node;\n  } else {\n    return findContainingNode(node.parent);\n  }\n};\n", "import {\n  getEffectFnRefs,\n  getEffectDepsRefs,\n  hasCleanup,\n  isUseEffect,\n  getUpstreamRefs,\n} from \"../util/ast.js\";\nimport { findDownstreamNodes, getDownstreamRefs } from \"../util/ast.js\";\nimport { isState } from \"../util/ast.js\";\n\n/**\n * @type {import(\"eslint\").Rule.RuleModule}\n */\nexport default {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"Disallow using state and an effect as an event handler.\",\n      url: \"https://react.dev/learn/you-might-not-need-an-effect#sharing-logic-between-event-handlers\",\n    },\n    schema: [],\n    messages: {\n      avoidEventHandler:\n        \"Avoid using state and effects as an event handler. Instead, call the event handling code directly when the event occurs.\",\n    },\n  },\n  create: (context) => ({\n    CallExpression: (node) => {\n      if (!isUseEffect(node) || hasCleanup(node)) return;\n      const effectFnRefs = getEffectFnRefs(context, node);\n      const depsRefs = getEffectDepsRefs(context, node);\n      if (!effectFnRefs || !depsRefs) return;\n\n      // TODO: Can we also flag this when the deps are internal, and the body calls internal stuff?\n      // That'd overlap with other rules though... maybe just useRefs?\n\n      findDownstreamNodes(context, node, \"IfStatement\")\n        .filter((ifNode) => !ifNode.alternate)\n        .filter((ifNode) =>\n          getDownstreamRefs(context, ifNode.test)\n            .flatMap((ref) => getUpstreamRefs(context, ref))\n            // TODO: Should flag props too, but maybe with a different message?\n            .notEmptyEvery((ref) => isState(ref)),\n        )\n        .forEach((ifNode) => {\n          context.report({\n            node: ifNode.test,\n            messageId: \"avoidEventHandler\",\n          });\n        });\n    },\n  }),\n};\n", "import {\n  getEffectFnRefs,\n  getEffectDepsRefs,\n  isImmediateCall,\n  isPropCallback,\n  isState,\n  isUseEffect,\n  getUpstreamRefs,\n} from \"../util/ast.js\";\nimport { getCallExpr, getDownstreamRefs } from \"../util/ast.js\";\n\n/**\n * @type {import(\"eslint\").Rule.RuleModule}\n */\nexport default {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description:\n        \"Disallow passing live state to parent components in an effect.\",\n      url: \"https://react.dev/learn/you-might-not-need-an-effect#notifying-parent-components-about-state-changes\",\n    },\n    schema: [],\n    messages: {\n      avoidPassingLiveStateToParent:\n        \"Avoid passing live state to parents in an effect. Instead, lift the state to the parent and pass it down to the child as a prop.\",\n    },\n  },\n  create: (context) => ({\n    CallExpression: (node) => {\n      if (!isUseEffect(node)) return;\n      const effectFnRefs = getEffectFnRefs(context, node);\n      const depsRefs = getEffectDepsRefs(context, node);\n      if (!effectFnRefs || !depsRefs) return;\n\n      effectFnRefs\n        .filter((ref) => isPropCallback(context, ref))\n        .filter((ref) => isImmediateCall(ref.identifier))\n        .forEach((ref) => {\n          const callExpr = getCallExpr(ref);\n          const isStateInArgs = callExpr.arguments\n            .flatMap((arg) => getDownstreamRefs(context, arg))\n            .flatMap((ref) => getUpstreamRefs(context, ref))\n            .some((ref) => isState(ref));\n\n          if (isStateInArgs) {\n            context.report({\n              node: callExpr,\n              messageId: \"avoidPassingLiveStateToParent\",\n            });\n          }\n        });\n    },\n  }),\n};\n", "import { getCallExpr } from \"../util/ast.js\";\nimport {\n  getEffectDepsRefs,\n  getEffectFnRefs,\n  getUseStateNode,\n  isImmediateCall,\n  isStateSetter,\n  isUseEffect,\n} from \"../util/ast.js\";\n\n/**\n * @type {import(\"eslint\").Rule.RuleModule}\n */\nexport default {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"Disallow initializing state in an effect.\",\n      url: \"https://tkdodo.eu/blog/avoiding-hydration-mismatches-with-use-sync-external-store\",\n    },\n    schema: [],\n    messages: {\n      avoidInitializingState:\n        'Avoid initializing state in an effect. Instead, initialize \"{{state}}\"\\'s `useState()` with \"{{arguments}}\". For SSR hydration, prefer `useSyncExternalStore()`.',\n    },\n  },\n  create: (context) => ({\n    CallExpression: (node) => {\n      if (!isUseEffect(node)) return;\n      const effectFnRefs = getEffectFnRefs(context, node);\n      const depsRefs = getEffectDepsRefs(context, node);\n      if (!effectFnRefs || !depsRefs) return;\n\n      // TODO: Should this length check account for the setter in the deps? exhaustive-deps doesn't warn one way or the other\n      if (depsRefs.length > 0) return;\n\n      effectFnRefs\n        .filter((ref) => isStateSetter(context, ref))\n        .filter((ref) => isImmediateCall(ref.identifier))\n        .forEach((ref) => {\n          const callExpr = getCallExpr(ref);\n          const useStateNode = getUseStateNode(context, ref);\n          const stateName = (\n            useStateNode.id.elements[0] ?? useStateNode.id.elements[1]\n          )?.name;\n          const argumentText = callExpr.arguments[0]\n            ? context.sourceCode.getText(callExpr.arguments[0])\n            : \"undefined\";\n\n          context.report({\n            node: getCallExpr(ref),\n            messageId: \"avoidInitializingState\",\n            data: { state: stateName, arguments: argumentText },\n          });\n        });\n    },\n  }),\n};\n", "import { getCallExpr, getUpstreamRefs } from \"../util/ast.js\";\nimport {\n  getEffectDepsRefs,\n  getEffectFnRefs,\n  hasCleanup,\n  isArgsAllLiterals,\n  isImmediateCall,\n  isState,\n  isStateSetter,\n  isUseEffect,\n} from \"../util/ast.js\";\n\n/**\n * @type {import(\"eslint\").Rule.RuleModule}\n */\nexport default {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"Disallow chaining state changes in an effect.\",\n      url: \"https://react.dev/learn/you-might-not-need-an-effect#chains-of-computations\",\n    },\n    schema: [],\n    messages: {\n      avoidChainingStateUpdates:\n        \"Avoid chaining state changes. When possible, update all relevant state simultaneously.\",\n    },\n  },\n  create: (context) => ({\n    CallExpression: (node) => {\n      if (!isUseEffect(node) || hasCleanup(node)) return;\n      const effectFnRefs = getEffectFnRefs(context, node);\n      const depsRefs = getEffectDepsRefs(context, node);\n      if (!effectFnRefs || !depsRefs) return;\n\n      // TODO: Should filter out setters before checking?\n      // exhaustive-deps doesn't enforce one way or the other.\n      const isAllDepsState = depsRefs\n        .flatMap((ref) => getUpstreamRefs(context, ref))\n        .notEmptyEvery((ref) => isState(ref));\n\n      effectFnRefs\n        .filter((ref) => isStateSetter(context, ref))\n        .filter((ref) => isImmediateCall(ref.identifier))\n        .forEach((ref) => {\n          const callExpr = getCallExpr(ref);\n\n          if (isAllDepsState && isArgsAllLiterals(context, callExpr)) {\n            context.report({\n              node: callExpr,\n              messageId: \"avoidChainingStateUpdates\",\n            });\n          }\n        });\n    },\n  }),\n};\n", "import {\n  getEffectFnRefs,\n  getEffectDepsRefs,\n  isImmediateCall,\n  isStateSetter,\n  getUseStateNode,\n  isProp,\n  isState,\n  hasCleanup,\n  isUseEffect,\n  getUpstreamRefs,\n} from \"../util/ast.js\";\nimport { getCallExpr, getDownstreamRefs } from \"../util/ast.js\";\n\n/**\n * @type {import('eslint').Rule.RuleModule}\n */\nexport default {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"Disallow storing derived state in an effect.\",\n      url: \"https://react.dev/learn/you-might-not-need-an-effect#updating-state-based-on-props-or-state\",\n    },\n    schema: [],\n    messages: {\n      avoidDerivedState:\n        'Avoid storing derived state. Compute \"{{state}}\" directly during render, optionally with `useMemo` if it\\'s expensive.',\n      avoidSingleSetter:\n        'Avoid storing derived state. \"{{state}}\" is only set here, and thus could be computed directly during render.',\n    },\n  },\n  create: (context) => ({\n    CallExpression: (node) => {\n      if (!isUseEffect(node) || hasCleanup(node)) return;\n      const effectFnRefs = getEffectFnRefs(context, node);\n      const depsRefs = getEffectDepsRefs(context, node);\n      if (!effectFnRefs || !depsRefs) return;\n\n      effectFnRefs\n        .filter((ref) => isStateSetter(context, ref))\n        .filter((ref) => isImmediateCall(ref.identifier))\n        .forEach((ref) => {\n          const callExpr = getCallExpr(ref);\n          const useStateNode = getUseStateNode(context, ref);\n          const stateName = (\n            useStateNode.id.elements[0] ?? useStateNode.id.elements[1]\n          )?.name;\n\n          const argsUpstreamRefs = callExpr.arguments\n            .flatMap((arg) => getDownstreamRefs(context, arg))\n            .flatMap((ref) => getUpstreamRefs(context, ref));\n          const depsUpstreamRefs = depsRefs.flatMap((ref) =>\n            getUpstreamRefs(context, ref),\n          );\n          const isAllArgsInternal = argsUpstreamRefs.notEmptyEvery(\n            (ref) => isState(ref) || isProp(ref),\n          );\n\n          const isAllArgsInDeps = argsUpstreamRefs.notEmptyEvery((argRef) =>\n            depsUpstreamRefs.some(\n              (depRef) => argRef.resolved.name === depRef.resolved.name,\n            ),\n          );\n          const isValueAlwaysInSync = isAllArgsInDeps && countCalls(ref) === 1;\n\n          if (isAllArgsInternal) {\n            context.report({\n              node: callExpr,\n              messageId: \"avoidDerivedState\",\n              data: { state: stateName },\n            });\n          } else if (isValueAlwaysInSync) {\n            context.report({\n              node: callExpr,\n              messageId: \"avoidSingleSetter\",\n              data: { state: stateName },\n            });\n          }\n        });\n    },\n  }),\n};\n\nconst countCalls = (ref) =>\n  ref.resolved.references.filter(\n    (ref) => ref.identifier.parent.type === \"CallExpression\",\n  ).length;\n", "import {\n  getEffectFnRefs,\n  getEffectDepsRefs,\n  isPropCallback,\n  isState,\n  isRef,\n  isProp,\n  hasCleanup,\n  isUseEffect,\n  getUpstreamRefs,\n  isImmediateCall,\n} from \"../util/ast.js\";\nimport { getCallExpr, getDownstreamRefs } from \"../util/ast.js\";\n\n/**\n * @type {import(\"eslint\").Rule.RuleModule}\n */\nexport default {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"Disallow passing data to parents in an effect.\",\n      url: \"https://react.dev/learn/you-might-not-need-an-effect#passing-data-to-the-parent\",\n    },\n    schema: [],\n    messages: {\n      avoidPassingDataToParent:\n        \"Avoid passing data to parents in an effect. Instead, let the parent fetch the data itself and pass it down to the child as a prop.\",\n    },\n  },\n  create: (context) => ({\n    CallExpression: (node) => {\n      if (!isUseEffect(node) || hasCleanup(node)) return;\n      const effectFnRefs = getEffectFnRefs(context, node);\n      const depsRefs = getEffectDepsRefs(context, node);\n      if (!effectFnRefs || !depsRefs) return;\n\n      effectFnRefs\n        .filter((ref) => isPropCallback(context, ref))\n        .filter((ref) => isImmediateCall(ref.identifier))\n        .forEach((ref) => {\n          const callExpr = getCallExpr(ref);\n\n          const isAllData =\n            callExpr.arguments.length &\n            callExpr.arguments\n              .flatMap((arg) => getDownstreamRefs(context, arg))\n              .flatMap((ref) => getUpstreamRefs(context, ref))\n              .notEmptyEvery(\n                (ref) => !isState(ref) && !isProp(ref) && !isRef(ref),\n              );\n\n          if (isAllData) {\n            context.report({\n              node: callExpr,\n              messageId: \"avoidPassingDataToParent\",\n            });\n          }\n        });\n    },\n  }),\n};\n", "import {\n  getEffectFnRefs,\n  getEffectDepsRefs,\n  isUseEffect,\n  getUpstreamRefs,\n} from \"../util/ast.js\";\nimport { isProp } from \"../util/ast.js\";\n\n/**\n * @type {import(\"eslint\").Rule.RuleModule}\n */\nexport default {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"Disallow effects that only use props.\",\n    },\n    schema: [],\n    messages: {\n      avoidManagingParent:\n        \"This effect only uses props. Consider lifting the logic up to the parent.\",\n    },\n  },\n  create: (context) => ({\n    CallExpression: (node) => {\n      if (!isUseEffect(node)) return;\n      const effectFnRefs = getEffectFnRefs(context, node);\n      const depsRefs = getEffectDepsRefs(context, node);\n      if (!effectFnRefs || !depsRefs) return;\n\n      if (effectFnRefs.length === 0) return;\n\n      const isAllProps = effectFnRefs\n        .concat(depsRefs)\n        .flatMap((ref) => getUpstreamRefs(context, ref))\n        .notEmptyEvery((ref) => isProp(ref));\n\n      if (isAllProps) {\n        context.report({\n          node,\n          messageId: \"avoidManagingParent\",\n        });\n      }\n    },\n  }),\n};\n", "import {\n  getEffectFnRefs,\n  getEffectDepsRefs,\n  isPropCallback,\n  isRef,\n  hasCleanup,\n  isUseEffect,\n  getUpstreamRefs,\n  isRefCall,\n} from \"../util/ast.js\";\nimport { getCallExpr, getDownstreamRefs } from \"../util/ast.js\";\n\n/**\n * @type {import(\"eslint\").Rule.RuleModule}\n */\nexport default {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description:\n        \"Disallow passing refs, or data from callbacks registered on them, to parents in an effect. Use `forwardRef` instead.\",\n      url: \"https://react.dev/reference/react/forwardRef\",\n    },\n    schema: [],\n    messages: {\n      avoidPassingRefToParent:\n        \"Avoid passing refs to parents in an effect. Use `forwardRef` instead.\",\n      avoidPropCallbackInRefCallback:\n        \"Avoid calling props inside callbacks registered on refs in an effect. Use `forwardRef` to register the callback in the parent instead.\",\n    },\n  },\n  create: (context) => ({\n    CallExpression: (node) => {\n      if (!isUseEffect(node) || hasCleanup(node)) return;\n      const effectFnRefs = getEffectFnRefs(context, node);\n      const depsRefs = getEffectDepsRefs(context, node);\n      if (!effectFnRefs || !depsRefs) return;\n\n      effectFnRefs\n        .filter((ref) => isPropCallback(context, ref))\n        .forEach((ref) => {\n          const callExpr = getCallExpr(ref);\n\n          const hasRefArg = callExpr.arguments\n            .flatMap((arg) => getDownstreamRefs(context, arg))\n            .flatMap((ref) => getUpstreamRefs(context, ref))\n            .some((ref) => isRef(ref));\n\n          if (hasRefArg) {\n            context.report({\n              node: callExpr,\n              messageId: \"avoidPassingRefToParent\",\n            });\n          }\n        });\n\n      effectFnRefs\n        .filter((ref) => isRefCall(context, ref))\n        .forEach((ref) => {\n          const callExpr = getCallExpr(ref);\n\n          const passesCallbackDataToParent = callExpr.arguments\n            .flatMap((arg) => getDownstreamRefs(context, arg))\n            .flatMap((ref) => getUpstreamRefs(context, ref))\n            .some((ref) => isPropCallback(context, ref));\n\n          if (passesCallbackDataToParent) {\n            context.report({\n              node: getCallExpr(ref),\n              messageId: \"avoidPropCallbackInRefCallback\",\n            });\n          }\n        });\n    },\n  }),\n};\n", "import noEmptyEffect from \"./rules/no-empty-effect.js\";\nimport noAdjustStateOnPropChange from \"./rules/no-adjust-state-on-prop-change.js\";\nimport noResetAllStateOnPropChange from \"./rules/no-reset-all-state-on-prop-change.js\";\nimport noEventHandler from \"./rules/no-event-handler.js\";\nimport noPassLiveStateToParent from \"./rules/no-pass-live-state-to-parent.js\";\nimport noInitializeState from \"./rules/no-initialize-state.js\";\nimport noChainStateUpdates from \"./rules/no-chain-state-updates.js\";\nimport noDerivedState from \"./rules/no-derived-state.js\";\nimport noPassDataToParent from \"./rules/no-pass-data-to-parent.js\";\nimport noManageParent from \"./rules/no-manage-parent.js\";\nimport noPassRefToParent from \"./rules/no-pass-ref-to-parent.js\";\nimport globals from \"globals\";\n\n/**\n * @type {import(\"eslint\").ESLint.Plugin}\n */\nconst plugin = {\n  meta: {\n    name: \"react-you-might-not-need-an-effect\",\n  },\n  configs: {},\n  rules: {\n    \"no-empty-effect\": noEmptyEffect,\n    \"no-adjust-state-on-prop-change\": noAdjustStateOnPropChange,\n    \"no-reset-all-state-on-prop-change\": noResetAllStateOnPropChange,\n    \"no-event-handler\": noEventHandler,\n    \"no-pass-live-state-to-parent\": noPassLiveStateToParent,\n    \"no-pass-data-to-parent\": noPassDataToParent,\n    \"no-manage-parent\": noManageParent,\n    \"no-pass-ref-to-parent\": noPassRefToParent,\n    \"no-initialize-state\": noInitializeState,\n    \"no-chain-state-updates\": noChainStateUpdates,\n    \"no-derived-state\": noDerivedState,\n  },\n};\n\nconst recommendedRules = Object.keys(plugin.rules).reduce((acc, ruleName) => {\n  acc[plugin.meta.name + \"/\" + ruleName] = \"warn\";\n  return acc;\n}, {});\nconst languageOptions = {\n  globals: {\n    // Required so we can resolve global references to their upstream global variables\n    ...globals.browser,\n  },\n  parserOptions: {\n    ecmaFeatures: {\n      jsx: true,\n    },\n  },\n};\n\nObject.assign(plugin.configs, {\n  // flat config format\n  recommended: {\n    files: [\"**/*.{js,jsx,mjs,cjs,ts,tsx,mts,cts}\"],\n    plugins: {\n      // Object.assign above so we can reference `plugin` here\n      [plugin.meta.name]: plugin,\n    },\n    rules: recommendedRules,\n    languageOptions,\n  },\n  \"legacy-recommended\": {\n    plugins: [plugin.meta.name],\n    rules: recommendedRules,\n    ...languageOptions,\n  },\n});\n\nexport default plugin;\n\n// Wraps `Array.every()` to return false for empty arrays.\nArray.prototype.notEmptyEvery = function (predicate) {\n  return this.length > 0 && this.every(predicate);\n};\n", "// `build.js` will bundle everything into CJS.\n// Would be nice to have it use `index.js` directly, but then `esbuild`\n// seems unable to structure the CJS export the way ESLint expects.\n// Seems we have to unwrap the default export ourselves for that.\nmodule.exports = require(\"./index.js\").default;\n"],
  "mappings": "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",
  "names": ["ref", "ref", "ref", "ref", "ref", "globals"]
}
