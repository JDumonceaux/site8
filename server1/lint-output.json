[{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\app\\routes\\artistRouter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\app\\routes\\artistsRouter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\app\\routes\\bookmarksRouter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\app\\routes\\buildRouter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\app\\routes\\createSimpleRouter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\app\\routes\\filesRouter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\app\\routes\\genericRouter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\app\\routes\\imageRouter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\app\\routes\\imagesRouter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\app\\routes\\itemsRouter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\app\\routes\\menuRouter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\app\\routes\\musicRouter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\app\\routes\\pageRouter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\app\\routes\\pagesRouter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\app\\routes\\photosRouter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\app\\routes\\testsRouter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\app\\routes\\travelRouter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\features\\artists\\ArtistsService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\features\\artists\\getArtists.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\features\\artists\\getArtistsItems.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\features\\bookmarks\\BookmarksService.ts","messages":[{"ruleId":"no-secrets/no-secrets","severity":2,"message":"Found a string with entropy 4.06 : \"cleanUpAndNormalizeTags\"","line":112,"column":9,"nodeType":"TemplateElement","messageId":"HIGH_ENTROPY","endLine":112,"endColumn":64}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { Bookmark , Bookmarks , BookmarksTag , BookmarksTags } from '@site8/shared';\r\n\r\nimport FilePath from '../../lib/filesystem/FilePath.js';\r\nimport { BaseDataService } from '../../services/BaseDataService.js';\r\nimport { Logger } from '../../utils/logger.js';\r\n\r\nexport class BookmarksService extends BaseDataService<Bookmarks> {\r\n  public constructor() {\r\n    super({\r\n      filePath: FilePath.getDataDir('bookmarks.json'),\r\n    });\r\n  }\r\n\r\n  public async getAllItems(): Promise<Bookmarks | undefined> {\r\n    Logger.info(`BookmarkService: getAllItems called`);\r\n\r\n    try {\r\n      const data = await this.readFile();\r\n      const sortedItems: Bookmark[] = data.items.toSorted((a, b) =>\r\n        a.name.localeCompare(b.name),\r\n      );\r\n      return { items: sortedItems, metadata: data.metadata };\r\n    } catch (error) {\r\n      const errorMessage =\r\n        error instanceof Error ? error.message : String(error);\r\n      Logger.error(`BookmarkService: getAllItems -> ${errorMessage}`, {\r\n        error,\r\n      });\r\n      throw new Error(`Failed to get all items: ${errorMessage}`);\r\n    }\r\n  }\r\n\r\n  public async getAllItemsByTag(): Promise<BookmarksTags | undefined> {\r\n    Logger.info(`BookmarkService: getAllItemsByTag called`);\r\n\r\n    try {\r\n      const data = await this.readFile();\r\n\r\n      // Clean up and normalize tags in bookmarks\r\n      const normalizedItems = this.cleanUpAndNormalizeTags(data.items);\r\n      if (!normalizedItems) {\r\n        throw new Error('Failed to normalize tags');\r\n      }\r\n\r\n      // Get unique tags from normalized items\r\n      const uniqueTags = this.getUniqueTags(normalizedItems);\r\n      if (!uniqueTags) {\r\n        throw new Error('Failed to retrieve unique tags');\r\n      }\r\n\r\n      // Remap bookmarks using the normalized items\r\n      const remappedBookmarks = this.remapBookmarks(\r\n        normalizedItems,\r\n        uniqueTags,\r\n      );\r\n      return { items: remappedBookmarks ?? [], metadata: data.metadata };\r\n    } catch (error) {\r\n      const errorMessage =\r\n        error instanceof Error ? error.message : String(error);\r\n      Logger.error(`BookmarkService: getAllItemsByTag -> ${errorMessage}`, {\r\n        error,\r\n      });\r\n      throw new Error(`Failed to get items by tag: ${errorMessage}`);\r\n    }\r\n  }\r\n\r\n  public async getBookmarksForPage(\r\n    pageId: string,\r\n  ): Promise<Bookmarks | undefined> {\r\n    Logger.info(`BookmarkService: getBookmarksForPage called`);\r\n\r\n    try {\r\n      const data = await this.readFile();\r\n      const searchId = parseInt(pageId, 10);\r\n      const filteredItems = data.items.filter((x) =>\r\n        x.page?.includes(searchId),\r\n      );\r\n      const sortedItems: Bookmark[] = filteredItems.toSorted((a, b) =>\r\n        a.name.localeCompare(b.name),\r\n      );\r\n      return { items: sortedItems, metadata: data.metadata };\r\n    } catch (error) {\r\n      Logger.error(\r\n        `BookmarkService: getBookmarksForPage --> Error: ${String(error)}`,\r\n      );\r\n      return undefined;\r\n    }\r\n  }\r\n\r\n  // Private helper to clean up and normalize tags in bookmarks\r\n  private cleanUpAndNormalizeTags(\r\n    items: Bookmark[] | undefined,\r\n  ): Bookmark[] | undefined {\r\n    if (!items) {\r\n      return undefined;\r\n    }\r\n    try {\r\n      return items.map((bookmark) => {\r\n        // Filter out empty or falsy tags\r\n        const nonEmptyTags = bookmark.tags?.filter((tag) => Boolean(tag));\r\n        // Default to 'General' if no valid tags remain\r\n        return {\r\n          ...bookmark,\r\n          tags:\r\n            nonEmptyTags && nonEmptyTags.length > 0\r\n              ? nonEmptyTags\r\n              : ['General'],\r\n        };\r\n      });\r\n    } catch (error) {\r\n      Logger.error(\r\n        `BookmarkService: cleanUpAndNormalizeTags --> Error: ${String(error)}`,\r\n      );\r\n      return undefined;\r\n    }\r\n  }\r\n\r\n  // Private helper to get unique tags from bookmarks\r\n  private getUniqueTags(items: Bookmark[] | undefined): string[] | undefined {\r\n    if (!items) {\r\n      return undefined;\r\n    }\r\n    try {\r\n      const uniqueTags = items.reduce<string[]>((acc: string[], item) => {\r\n        if (item.tags) {\r\n          const newTags = item.tags.filter((tag) => !acc.includes(tag));\r\n          return [...acc, ...newTags];\r\n        }\r\n        return acc;\r\n      }, []);\r\n      Object.freeze(uniqueTags);\r\n      return uniqueTags.toSorted();\r\n    } catch (error) {\r\n      Logger.error(\r\n        `BookmarkService: getUniqueTags --> Error: ${String(error)}`,\r\n      );\r\n      return undefined;\r\n    }\r\n  }\r\n\r\n  // Private helper to remap bookmarks by tag\r\n  private remapBookmarks(\r\n    items: Bookmark[] | undefined,\r\n    tags: string[] | undefined,\r\n  ): BookmarksTag[] | undefined {\r\n    if (!items || !tags) {\r\n      return undefined;\r\n    }\r\n    try {\r\n      return tags.map((tag) => {\r\n        const filteredItems = items.filter((bookmark) =>\r\n          bookmark.tags?.includes(tag),\r\n        );\r\n        const sortedItems = filteredItems.toSorted((a, b) =>\r\n          a.name.localeCompare(b.name),\r\n        );\r\n        return {\r\n          items: sortedItems,\r\n          tag,\r\n        };\r\n      });\r\n    } catch (error) {\r\n      Logger.error(\r\n        `BookmarkService: remapBookmarks --> Error: ${String(error)}`,\r\n      );\r\n      return undefined;\r\n    }\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\features\\bookmarks\\getItems.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\features\\bookmarks\\getItemsPage.ts","messages":[{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":15,"column":42,"nodeType":"ChainExpression","messageId":"neverNullish","endLine":15,"endColumn":60},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":15,"column":52,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":15,"endColumn":54,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[665,667],"text":"."},"desc":"Remove unnecessary optional chain"}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { Bookmarks } from '@site8/shared';\r\n\r\nimport { createGetHandlerWithParams } from '../../lib/http/genericHandlers.js';\r\nimport { getBookmarksService } from '../../utils/ServiceFactory.js';\r\n\r\nexport const getItemsPage = createGetHandlerWithParams<Bookmarks>({\r\n  errorResponse: { items: [], metadata: { title: 'Bookmarks' } },\r\n  getData: async (req) => {\r\n    const { id } = req.params;\r\n    const service = getBookmarksService();\r\n    const result = await service.getBookmarksForPage(id ?? '');\r\n    return result ?? { items: [], metadata: { title: 'Bookmarks' } };\r\n  },\r\n  getItemCount: (data) =>\r\n    Array.isArray(data) ? data.length : (data.items?.length ?? 0),\r\n  handlerName: 'Bookmarks:getItemsPage',\r\n  return204OnEmpty: true,\r\n  validateParams: (req) => {\r\n    const { id } = req.params;\r\n    if (!id) {\r\n      return { errorMessage: 'Missing page id parameter', isValid: false };\r\n    }\r\n    return { isValid: true };\r\n  },\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\features\\bookmarks\\getTags.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\features\\image\\ImageService.ts","messages":[{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":116,"column":46,"nodeType":"MemberExpression","messageId":"neverNullish","endLine":116,"endColumn":63},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":167,"column":12,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":167,"endColumn":23},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":185,"column":9,"nodeType":"MemberExpression","endLine":185,"endColumn":20},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":185,"column":23,"nodeType":"MemberExpression","endLine":185,"endColumn":31},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":187,"column":9,"nodeType":"MemberExpression","endLine":187,"endColumn":20},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":187,"column":23,"nodeType":"MemberExpression","endLine":187,"endColumn":65},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":189,"column":9,"nodeType":"MemberExpression","endLine":189,"endColumn":20},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":208,"column":12,"nodeType":"TSAsExpression","messageId":"neverNullish","endLine":208,"endColumn":31},{"ruleId":"security/detect-object-injection","severity":1,"message":"Variable Assigned to Object Injection Sink","line":215,"column":19,"nodeType":"MemberExpression","endLine":215,"endColumn":27},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":217,"column":16,"nodeType":"MemberExpression","endLine":217,"endColumn":24},{"ruleId":"@typescript-eslint/no-dynamic-delete","severity":2,"message":"Do not delete dynamically computed property keys.","line":217,"column":20,"nodeType":"Identifier","messageId":"dynamicDelete","endLine":217,"endColumn":23},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":223,"column":18,"nodeType":"MemberExpression","endLine":223,"endColumn":26},{"ruleId":"@typescript-eslint/no-dynamic-delete","severity":2,"message":"Do not delete dynamically computed property keys.","line":223,"column":22,"nodeType":"Identifier","messageId":"dynamicDelete","endLine":223,"endColumn":25},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":225,"column":11,"nodeType":"MemberExpression","endLine":225,"endColumn":19},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":230,"column":38,"nodeType":"MemberExpression","endLine":230,"endColumn":46},{"ruleId":"@typescript-eslint/no-dynamic-delete","severity":2,"message":"Do not delete dynamically computed property keys.","line":230,"column":42,"nodeType":"Identifier","messageId":"dynamicDelete","endLine":230,"endColumn":45},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always truthy.","line":234,"column":13,"nodeType":"Identifier","messageId":"alwaysTruthy","endLine":234,"endColumn":16},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":235,"column":18,"nodeType":"MemberExpression","endLine":235,"endColumn":26},{"ruleId":"@typescript-eslint/no-dynamic-delete","severity":2,"message":"Do not delete dynamically computed property keys.","line":235,"column":22,"nodeType":"Identifier","messageId":"dynamicDelete","endLine":235,"endColumn":25}],"suppressedMessages":[],"errorCount":8,"fatalErrorCount":0,"warningCount":11,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { ImagesService } from '../images/ImagesService.js';\r\nimport type { Image, ImageAdd, ImageEdit , Images } from '@site8/shared';\r\n\r\nimport { Logger } from '../../utils/logger.js';\r\nimport { cleanUpData } from '../../utils/objectUtil.js';\r\nimport { getImagesService } from '../../utils/ServiceFactory.js';\r\n\r\nexport class ImageService {\r\n  public async addItem(data: ImageAdd): Promise<number> {\r\n    Logger.info('ImageService: addItem ->');\r\n    const imagesService = this.getImagesService();\r\n\r\n    try {\r\n      const updatedItem = cleanUpData<ImageAdd>(data);\r\n      const currentData = await imagesService.getItems();\r\n      if (!currentData) {\r\n        throw new Error('addItem -> No data found');\r\n      }\r\n      const idNew = (await imagesService.getNextId()) ?? 0;\r\n\r\n      // Build new Image using allowed properties only\r\n      const baseItem: Image = {\r\n        description: updatedItem.description ?? '',\r\n        ext_url: '',\r\n        fileName: updatedItem.fileName ?? '',\r\n        folder: updatedItem.folder ?? '',\r\n        id: idNew,\r\n        name: updatedItem.name ?? '',\r\n      };\r\n\r\n      const sanitizedNew = this.pickImageFields(baseItem);\r\n      const sanitizedNewRecord = {\r\n        ...(sanitizedNew as Record<string, unknown>),\r\n      } as Record<string, unknown>;\r\n      this.removeEmptyAttributesExceptId(sanitizedNewRecord);\r\n      const finalNew = sanitizedNewRecord as Image;\r\n\r\n      const updatedFile: Images = {\r\n        items: [...(currentData.items ?? []), finalNew],\r\n        metadata: currentData.metadata,\r\n      };\r\n      await this.writeImageData(imagesService, updatedFile);\r\n      return idNew;\r\n    } catch (error) {\r\n      Logger.error(`ImageService: addItem -> ${String(error)}`);\r\n      throw new Error('add failed');\r\n    }\r\n  }\r\n\r\n  public async deleteItem(id: number): Promise<Image | undefined> {\r\n    Logger.info(`ImageService: deleteItem -> id: ${id}`);\r\n    const imagesService = this.getImagesService();\r\n\r\n    try {\r\n      const currentData = await imagesService.getItems();\r\n      if (!currentData?.items) {\r\n        throw new Error('deleteItem -> No data found');\r\n      }\r\n      const itemToDelete = currentData.items.find((item) => item.id === id);\r\n      if (!itemToDelete) {\r\n        Logger.warn(`ImageService: deleteItem -> Item with id ${id} not found`);\r\n        return undefined;\r\n      }\r\n      const updatedItems = currentData.items.filter((item) => item.id !== id);\r\n      const updatedFile: Images = {\r\n        items: updatedItems,\r\n        metadata: currentData.metadata,\r\n      };\r\n      await this.writeImageData(imagesService, updatedFile);\r\n      return itemToDelete;\r\n    } catch (error) {\r\n      Logger.error(`ImageService: deleteItem -> ${String(error)}`);\r\n      throw new Error('delete failed');\r\n    }\r\n  }\r\n\r\n  public async getItem(id: number): Promise<Image | undefined> {\r\n    Logger.info(`ImageService: Fetching item with ID -> ${id}`);\r\n    const imagesService = this.getImagesService();\r\n\r\n    try {\r\n      const response = await imagesService.getItems();\r\n      if (!response?.items) {\r\n        Logger.warn(\r\n          `ImageService: No data found while fetching item with ID -> ${id}`,\r\n        );\r\n        throw new Error('No data found');\r\n      }\r\n      const item = response.items.find((x) => x.id === id);\r\n      if (!item) {\r\n        Logger.warn(`ImageService: Item with ID -> ${id} not found`);\r\n      }\r\n      return item;\r\n    } catch (error) {\r\n      const errorMessage = (error as Error).message;\r\n      Logger.error(\r\n        `ImageService: Error fetching item with ID -> ${id}. Details: ${errorMessage}`,\r\n        error,\r\n      );\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  public async patchItem(\r\n    data: Partial<ImageEdit> & { id: number },\r\n  ): Promise<number> {\r\n    Logger.info('ImageService: patchItem ->');\r\n    const imagesService = this.getImagesService();\r\n\r\n    try {\r\n      const updatedItem = cleanUpData(data);\r\n      const currentData = await imagesService.getItems();\r\n      if (!currentData?.items) {\r\n        throw new Error('patchItem -> No data found');\r\n      }\r\n      const existing = this.findExistingItem(currentData.items ?? [], data.id);\r\n      const mergedBase: Image = {\r\n        ...existing,\r\n        ...updatedItem,\r\n        id: existing.id,\r\n      };\r\n      const finalMerged = this.sanitizeImageItem(mergedBase);\r\n\r\n      // Validate that finalMerged has at least one field besides id\r\n      const fieldsWithoutId = Object.keys(finalMerged).filter(\r\n        (key) => key !== 'id',\r\n      );\r\n      if (fieldsWithoutId.length === 0) {\r\n        throw new Error(\r\n          'patchItem -> finalMerged contains only id, no valid fields to update',\r\n        );\r\n      }\r\n\r\n      const updatedFile = this.replaceItemInCollection(\r\n        currentData,\r\n        finalMerged,\r\n      );\r\n\r\n      await this.writeImageData(imagesService, updatedFile);\r\n      return finalMerged.id;\r\n    } catch (error) {\r\n      Logger.error(`ImageService: patchItem -> ${String(error)}`);\r\n      throw new Error('patch failed');\r\n    }\r\n  }\r\n\r\n  // Backwards-compatible alias for callers expecting updateItem\r\n  public async updateItem(\r\n    data: Partial<ImageEdit> & { id: number },\r\n  ): Promise<number> {\r\n    return this.patchItem(data);\r\n  }\r\n\r\n  /**\r\n   * Find existing item by ID with validation\r\n   */\r\n  private findExistingItem(items: readonly Image[], id: number): Image {\r\n    const matches = items.filter((x) => x.id === id);\r\n    if (matches.length === 0) {\r\n      throw new Error(`patchItem -> Item with id ${id} not found`);\r\n    }\r\n    if (matches.length > 1) {\r\n      throw new Error(\r\n        `patchItem -> Multiple items with id ${id} found: ${matches.length}`,\r\n      );\r\n    }\r\n    return matches[0]!;\r\n  }\r\n\r\n  private getImagesService(): ImagesService {\r\n    const service = getImagesService();\r\n    // Access writeFile through public method if needed\r\n    return service;\r\n  }\r\n\r\n  private pickFields<T extends Record<string, unknown>>(\r\n    obj: Record<string, unknown>,\r\n    keys: (keyof T)[],\r\n    defaults: Partial<T> = {},\r\n  ): T {\r\n    const result: Record<string, unknown> = {};\r\n    for (const k of keys) {\r\n      const key = String(k);\r\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\r\n        result[key] = obj[key];\r\n      } else if (Object.prototype.hasOwnProperty.call(defaults, key)) {\r\n        result[key] = (defaults as Record<string, unknown>)[key];\r\n      } else {\r\n        result[key] = undefined;\r\n      }\r\n    }\r\n\r\n    return cleanUpData(result as T);\r\n  }\r\n\r\n  private pickImageFields(obj: Record<string, unknown>): Image {\r\n    // Explicitly define allowed Image fields\r\n    const allowedKeys: (keyof Image)[] = [\r\n      'id',\r\n      'name',\r\n      'fileName',\r\n      'folder',\r\n      'ext_url',\r\n      'tags',\r\n      'description',\r\n    ];\r\n    return this.pickFields<Image>(obj, allowedKeys, {\r\n      id: (obj['id'] as number) ?? 0,\r\n    });\r\n  }\r\n\r\n  private removeEmptyAttributesExceptId(obj: Record<string, unknown>): void {\r\n    for (const key of Object.keys(obj)) {\r\n      if (key === 'id') continue;\r\n      const val = obj[key];\r\n      if (val === undefined || val === null) {\r\n        delete obj[key];\r\n        continue;\r\n      }\r\n      if (typeof val === 'string') {\r\n        const trimmed = val.trim();\r\n        if (trimmed === '') {\r\n          delete obj[key];\r\n        } else {\r\n          obj[key] = trimmed;\r\n        }\r\n        continue;\r\n      }\r\n      if (Array.isArray(val)) {\r\n        if (val.length === 0) delete obj[key];\r\n        continue;\r\n      }\r\n      if (typeof val === 'object') {\r\n        if (val && Object.keys(val as Record<string, unknown>).length === 0) {\r\n          delete obj[key];\r\n        }\r\n        continue;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Replace an item in the collection and return updated Images\r\n   */\r\n  private replaceItemInCollection(\r\n    currentData: Images,\r\n    updatedItem: Image,\r\n  ): Images {\r\n    const items = currentData.items ?? [];\r\n    const updatedItems = items.map((it) =>\r\n      it.id === updatedItem.id ? updatedItem : it,\r\n    );\r\n\r\n    return {\r\n      items: updatedItems,\r\n      metadata: currentData.metadata,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Sanitize image item by picking valid fields and removing empty attributes\r\n   */\r\n  private sanitizeImageItem(item: Image): Image {\r\n    const sanitized = this.pickImageFields(item);\r\n    const record = {\r\n      ...(sanitized as Record<string, unknown>),\r\n    } as Record<string, unknown>;\r\n    this.removeEmptyAttributesExceptId(record);\r\n    return record as Image;\r\n  }\r\n\r\n  private async writeImageData(\r\n    service: ImagesService,\r\n    data: Images,\r\n  ): Promise<void> {\r\n    await service.writeData(data);\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\features\\image\\deleteItem.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\features\\image\\getItem.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\features\\image\\patchItem.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\features\\image\\postItem.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\features\\images\\ImagesFileService.ts","messages":[{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found readdirSync from package \"fs\" with non literal argument at index 0","line":22,"column":21,"nodeType":"CallExpression","endLine":25,"endColumn":9},{"ruleId":"n/no-sync","severity":1,"message":"Unexpected sync method: 'readdirSync'.","line":22,"column":21,"nodeType":"CallExpression","messageId":"noSync","endLine":25,"endColumn":9},{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found statSync from package \"fs\" with non literal argument at index 0","line":29,"column":23,"nodeType":"CallExpression","endLine":29,"endColumn":41},{"ruleId":"n/no-sync","severity":1,"message":"Unexpected sync method: 'statSync'.","line":29,"column":23,"nodeType":"CallExpression","messageId":"noSync","endLine":29,"endColumn":41},{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found renameSync from package \"fs\" with non literal argument at index 0,1","line":31,"column":11,"nodeType":"CallExpression","endLine":31,"endColumn":55},{"ruleId":"n/no-sync","severity":1,"message":"Unexpected sync method: 'renameSync'.","line":31,"column":11,"nodeType":"CallExpression","messageId":"noSync","endLine":31,"endColumn":55},{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found readdirSync from package \"fs\" with non literal argument at index 0","line":52,"column":21,"nodeType":"CallExpression","endLine":56,"endColumn":9},{"ruleId":"n/no-sync","severity":1,"message":"Unexpected sync method: 'readdirSync'.","line":52,"column":21,"nodeType":"CallExpression","messageId":"noSync","endLine":56,"endColumn":9},{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found existsSync from package \"fs\" with non literal argument at index 0","line":140,"column":16,"nodeType":"CallExpression","endLine":140,"endColumn":38},{"ruleId":"n/no-sync","severity":1,"message":"Unexpected sync method: 'existsSync'.","line":140,"column":16,"nodeType":"CallExpression","messageId":"noSync","endLine":140,"endColumn":38},{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found mkdirSync from package \"fs\" with non literal argument at index 0","line":142,"column":13,"nodeType":"CallExpression","endLine":142,"endColumn":34},{"ruleId":"n/no-sync","severity":1,"message":"Unexpected sync method: 'mkdirSync'.","line":142,"column":13,"nodeType":"CallExpression","messageId":"noSync","endLine":142,"endColumn":34},{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found existsSync from package \"fs\" with non literal argument at index 0","line":150,"column":13,"nodeType":"CallExpression","endLine":150,"endColumn":31},{"ruleId":"n/no-sync","severity":1,"message":"Unexpected sync method: 'existsSync'.","line":150,"column":13,"nodeType":"CallExpression","messageId":"noSync","endLine":150,"endColumn":31},{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found renameSync from package \"fs\" with non literal argument at index 0,1","line":156,"column":11,"nodeType":"CallExpression","endLine":156,"endColumn":43},{"ruleId":"n/no-sync","severity":1,"message":"Unexpected sync method: 'renameSync'.","line":156,"column":11,"nodeType":"CallExpression","messageId":"noSync","endLine":156,"endColumn":43},{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found readdirSync from package \"fs\" with non literal argument at index 0","line":178,"column":21,"nodeType":"CallExpression","endLine":181,"endColumn":9},{"ruleId":"n/no-sync","severity":1,"message":"Unexpected sync method: 'readdirSync'.","line":178,"column":21,"nodeType":"CallExpression","messageId":"noSync","endLine":181,"endColumn":9},{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found statSync from package \"fs\" with non literal argument at index 0","line":183,"column":23,"nodeType":"CallExpression","endLine":183,"endColumn":41},{"ruleId":"n/no-sync","severity":1,"message":"Unexpected sync method: 'statSync'.","line":183,"column":23,"nodeType":"CallExpression","messageId":"noSync","endLine":183,"endColumn":41}],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always falsy.","line":114,"column":11,"nodeType":"UnaryExpression","messageId":"alwaysFalsy","endLine":114,"endColumn":19,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":20,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { Image, ImageEdit , Images } from '@site8/shared';\r\n\r\nimport { existsSync, mkdirSync, readdirSync, renameSync, statSync } from 'fs';\r\nimport path from 'path';\r\n\r\nimport FilePath from '../../lib/filesystem/FilePath.js';\r\nimport { FOLDERS_TO_IGNORE } from '../../utils/constants.js';\r\nimport { Logger } from '../../utils/logger.js';\r\nimport { getImagesService } from '../../utils/ServiceFactory.js';\r\n\r\nexport class ImagesFileService {\r\n  private readonly imageDir: string = '';\r\n\r\n  public constructor() {\r\n    this.imageDir = FilePath.getImageDirAbsolute();\r\n  }\r\n\r\n  public fixNames(): boolean {\r\n    try {\r\n      // All the files and all the directories\r\n      // If encoding is missing, returns buffer vs. strings\r\n      const items = readdirSync(this.imageDir, {\r\n        encoding: 'utf8',\r\n        recursive: true,\r\n      });\r\n\r\n      items.forEach((item) => {\r\n        const itemPath = path.join(this.imageDir, item);\r\n        const stats = statSync(itemPath);\r\n        if (stats.isFile()) {\r\n          renameSync(itemPath, itemPath.toLowerCase());\r\n        }\r\n      });\r\n\r\n      return true;\r\n    } catch (error) {\r\n      Logger.error(`ImagesFileService: fixNames -> ${String(error)}`);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Retrieves the list of folders in the specified path.\r\n   *\r\n   * @returns An array of folder names.\r\n   */\r\n  public getFolders() {\r\n    try {\r\n      // All the files and all the directories\r\n      // If encoding is missing, returns buffer vs. strings\r\n      // NOTE: path is deprecated, but replacement - parentPath - isn't working\r\n      const items = readdirSync(this.imageDir, {\r\n        encoding: 'utf8',\r\n        recursive: true,\r\n        withFileTypes: true,\r\n      })\r\n        .filter((x) => x.isDirectory())\r\n        .map((x) => x.parentPath + '\\\\' + x.name)\r\n        .map((x) => x.substring(this.imageDir.length + 1).trim())\r\n        .filter((x) => !FOLDERS_TO_IGNORE.some((y) => x.startsWith(y)))\r\n        .toSorted((a, b) => a.localeCompare(b));\r\n      return items;\r\n    } catch (error) {\r\n      Logger.error(`ImagesFileService: getFolders -> ${String(error)}`);\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  // Get all data\r\n  public getItemsFromBaseDirectory(): Image[] | undefined {\r\n    return this.getItemsFromDirectory(this.imageDir);\r\n  }\r\n\r\n  // Get \"items\" from 'sort' directory\r\n  public getItemsFromSortDirectory(): Image[] | undefined {\r\n    return this.getItemsFromDirectory(this.imageDir, 'sort');\r\n  }\r\n\r\n  // Get all data\r\n  public async getMatchedItems(): Promise<Images | undefined> {\r\n    try {\r\n      const items = this.getItemsFromBaseDirectory();\r\n      const x = await this.matchItems(items);\r\n      return { items: x, metadata: { title: 'Images' } };\r\n    } catch (error) {\r\n      Logger.error(`ImagesFileService: getMatchedItems -> ${String(error)}`);\r\n      return undefined;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Retrieves new items from the sort directory.\r\n   * @returns A Promise that resolves to an object of type Images or undefined.\r\n   */\r\n  public getNewItems(): Images | undefined {\r\n    const items = this.getItemsFromSortDirectory();\r\n    return { items: items, metadata: { title: 'Images' } };\r\n  }\r\n\r\n  /**\r\n   * Moves the specified items to a new location.\r\n   * @param items - An array of ImageEdit objects representing the items to be moved.\r\n   * @returns A Promise that resolves to a boolean indicating whether the move operation was successful.\r\n   */\r\n  public moveItems(items: readonly ImageEdit[] | undefined): boolean {\r\n    try {\r\n      Logger.info(\r\n        `ImagesFileService: moveItems. -> (${items ? items.length : 0}) to move.`,\r\n      );\r\n\r\n      const updates: readonly ImageEdit[] = []; //items?.filter((x) => x.originalFolder !== x.folder);\r\n\r\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\r\n      if (!updates || updates.length === 0) {\r\n        Logger.info(`ImagesFileService: moveItems. -> no items to update`);\r\n        return true;\r\n      }\r\n\r\n      for (const item of updates) {\r\n        if (!item.fileName || !item.folder) {\r\n          Logger.error(\r\n            `ImagesFileService: moveItems -> fileName or folder is missing.`,\r\n          );\r\n          return false;\r\n        }\r\n\r\n        const { originalFolder } = item as ImageEdit & {\r\n          originalFolder?: string;\r\n        };\r\n        const currLocation = path.join(\r\n          this.imageDir,\r\n          originalFolder ?? '',\r\n          item.fileName,\r\n        );\r\n        const moveTo = path.join(this.imageDir, item.folder, item.fileName);\r\n        const moveToPath = path.join(this.imageDir, item.folder);\r\n\r\n        // Create the folder if needed\r\n        try {\r\n          if (!existsSync(moveToPath)) {\r\n            Logger.info(`ImagesFileService: creating folder -> ${moveToPath}.`);\r\n            mkdirSync(moveToPath);\r\n          }\r\n        } catch (err) {\r\n          Logger.error(\r\n            `ImagesFileService: Error creating folder -> ${String(err)}`,\r\n          );\r\n        }\r\n\r\n        if (existsSync(moveTo)) {\r\n          Logger.warn(\r\n            `ImagesFileService: Unable to move file -> ${moveTo} already exists.`,\r\n          );\r\n          return false;\r\n        } else {\r\n          renameSync(currLocation, moveTo);\r\n        }\r\n      }\r\n      return true;\r\n    } catch (error) {\r\n      Logger.error(`ImagesFileService: moveItems ->  ${String(error)}`);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  private getItemsFromDirectory(\r\n    basePath: string,\r\n    addPath?: string,\r\n  ): Image[] | undefined {\r\n    try {\r\n      const fullPath = addPath ? path.join(basePath, addPath) : basePath;\r\n      Logger.info(\r\n        `ImagesFileService: getItemsFromDirectory -> path: ${fullPath}`,\r\n      );\r\n\r\n      // All the files and all the directories\r\n      // If encoding is missing, returns buffer vs. strings\r\n      const items = readdirSync(fullPath, {\r\n        encoding: 'utf8',\r\n        recursive: true,\r\n      }).filter((item) => {\r\n        const itemPath = path.join(fullPath, item);\r\n        const stats = statSync(itemPath);\r\n        return stats.isFile();\r\n      });\r\n\r\n      // Return a list of images\r\n      const ret: Image[] = items.map((x) => {\r\n        return {\r\n          fileName: path.basename(x),\r\n          folder: path.dirname(x),\r\n        };\r\n      }) as Image[];\r\n\r\n      // Filter out 'site' folder\r\n      const filteredImages = ret.filter((x) => x.folder != 'site');\r\n\r\n      return filteredImages;\r\n    } catch (error) {\r\n      Logger.error(\r\n        `ImagesFileService: getItemsFromDirectory -> ${String(error)}`,\r\n      );\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  private async matchItems(\r\n    items: Image[] | undefined,\r\n  ): Promise<Image[] | undefined> {\r\n    try {\r\n      const service = getImagesService();\r\n      const data = await service.getItems();\r\n\r\n      if (!data) {\r\n        return items;\r\n      }\r\n\r\n      if (!items) {\r\n        return undefined;\r\n      }\r\n\r\n      const ret = items.map((item) => {\r\n        // Try to match by src if present, otherwise fall back to filename\r\n        const itemSrc = (item as { src?: string }).src;\r\n        const matched = itemSrc\r\n          ? data.items?.find((x) => (x as { src?: string }).src === itemSrc)\r\n          : data.items?.find((x) => x.fileName === item.fileName);\r\n\r\n        return {\r\n          ...item,\r\n          isMatched: !!matched,\r\n          matchedId: matched?.id ?? 0,\r\n        } as Image;\r\n      });\r\n\r\n      return ret;\r\n    } catch (error) {\r\n      Logger.error(`ImagesFileService: matchItems -> ${String(error)}`);\r\n      return undefined;\r\n    }\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\features\\images\\ImagesService.ts","messages":[{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":25,"column":30,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":25,"endColumn":32,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[763,765],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":32,"column":19,"nodeType":"ChainExpression","messageId":"neverNullish","endLine":32,"endColumn":33},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":32,"column":23,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":32,"endColumn":25,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[927,929],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":49,"column":30,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":49,"endColumn":32,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[1434,1436],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":59,"column":19,"nodeType":"ChainExpression","messageId":"neverNullish","endLine":59,"endColumn":33},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":59,"column":23,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":59,"endColumn":25,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[1698,1700],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always falsy.","line":80,"column":9,"nodeType":"UnaryExpression","messageId":"alwaysFalsy","endLine":80,"endColumn":15},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":89,"column":32,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":89,"endColumn":34,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[2750,2752],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":102,"column":30,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":102,"endColumn":32,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[3069,3071],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":136,"column":16,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":136,"endColumn":18,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[4185,4187],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always falsy.","line":152,"column":9,"nodeType":"UnaryExpression","messageId":"alwaysFalsy","endLine":152,"endColumn":19},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'moveItemFiles' has no 'await' expression.","line":161,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":161,"endColumn":30,"suggestions":[{"messageId":"removeAsync","fix":{"range":[4903,4960],"text":"moveItemFiles(updatedItems: Image[]): void"},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always falsy.","line":236,"column":11,"nodeType":"UnaryExpression","messageId":"alwaysFalsy","endLine":236,"endColumn":16}],"suppressedMessages":[],"errorCount":13,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { Image , Images } from '@site8/shared';\r\n\r\nimport FilePath from '../../lib/filesystem/FilePath.js';\r\nimport { BaseDataService } from '../../services/BaseDataService.js';\r\nimport { Logger } from '../../utils/logger.js';\r\nimport {\r\n  cleanUpData,\r\n  getNextId as getNextIdUtil,\r\n} from '../../utils/objectUtil.js';\r\nimport { getImagesFileService } from '../../utils/ServiceFactory.js';\r\n\r\nimport { getNewIds, getNewItems } from './imagesUtil.js';\r\n\r\nexport class ImagesService extends BaseDataService<Images> {\r\n  public constructor() {\r\n    super({\r\n      filePath: FilePath.getDataDir('images.json'),\r\n    });\r\n  }\r\n\r\n  public async fixIndex(): Promise<boolean> {\r\n    try {\r\n      const item = await this.readFile();\r\n\r\n      const fixedItems = item?.items?.map((x, index) => ({\r\n        ...x,\r\n        id: index + 1,\r\n      }));\r\n\r\n      const data: Images = {\r\n        items: fixedItems,\r\n        metadata: item?.metadata ?? { title: 'Images' },\r\n      };\r\n\r\n      await this.writeData(data);\r\n      return true;\r\n    } catch (error) {\r\n      const errorMessage =\r\n        error instanceof Error ? error.message : String(error);\r\n      Logger.error(`ImagesService: fixIndex -> ${errorMessage}`, { error });\r\n      throw new Error(`Failed to fix index: ${errorMessage}`);\r\n    }\r\n  }\r\n\r\n  public async fixNames(): Promise<boolean> {\r\n    try {\r\n      const item = await this.readFile();\r\n\r\n      const fixedItems = item?.items?.map((x) => {\r\n        const fixed = { ...x };\r\n        if (x.fileName) {\r\n          fixed.fileName = x.fileName.toLowerCase();\r\n        }\r\n        return fixed;\r\n      });\r\n\r\n      const data: Images = {\r\n        items: fixedItems,\r\n        metadata: item?.metadata ?? { title: 'Images' },\r\n      };\r\n\r\n      await this.writeData(data);\r\n      return true;\r\n    } catch (error) {\r\n      const errorMessage =\r\n        error instanceof Error ? error.message : String(error);\r\n      Logger.error(`ImagesService: fixNames -> ${errorMessage}`, { error });\r\n      throw new Error(`Failed to fix names: ${errorMessage}`);\r\n    }\r\n  }\r\n\r\n  // Get all data - uses BaseDataService implementation\r\n  // Override not needed as base class provides this functionality\r\n\r\n  // Yes, this is a duplicate of getItems.  It's here for clarity and in case\r\n  // we need to add additional logic to getItems in the future.\r\n  public async getItemsEdit(): Promise<Images | undefined> {\r\n    // Get current items\r\n    const items = await this.readFile();\r\n    if (!items) {\r\n      throw new Error('getItemsEdit > Index file not loaded');\r\n    }\r\n    return { ...items };\r\n  }\r\n\r\n  public override async getNextId(): Promise<number | undefined> {\r\n    try {\r\n      const data = await this.readFile();\r\n      return getNextIdUtil(data?.items);\r\n    } catch (error) {\r\n      Logger.error(`ImagesService: getNextId -> ${String(error)}`);\r\n      return undefined;\r\n    }\r\n  }\r\n\r\n  public override async listDuplicates(): Promise<{\r\n    readonly items: string[];\r\n  }> {\r\n    try {\r\n      const item = await this.readFile();\r\n\r\n      const duplicates = item?.items\r\n        ?.map((x) => x.fileName)\r\n        .filter((x, i, a) => a.indexOf(x) !== i);\r\n\r\n      // Filter out null and undefined\r\n      const filtered = duplicates?.filter((x): x is string => x !== undefined);\r\n\r\n      return { items: filtered ?? [] };\r\n    } catch (error) {\r\n      Logger.error(`ImagesService: listDuplicates -> ${String(error)}`);\r\n      return { items: [] };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Retrieves new items from the /images directory and updates the existing items.\r\n   * @returns A Promise that resolves to the updated Images object, or undefined if an error occurs.\r\n   */\r\n  public async scanForNewItems(): Promise<Images | undefined> {\r\n    // Update the index file with new items\r\n    await this.updateIndexWithNewItems();\r\n\r\n    return this.getNewItems();\r\n  }\r\n\r\n  public async updateItems(\r\n    items: readonly Image[] | undefined,\r\n  ): Promise<boolean> {\r\n    if (!items || !Array.isArray(items) || items.length === 0) {\r\n      Logger.info(`ImagesService: updateItems -> no items to update`);\r\n      return true;\r\n    }\r\n\r\n    const images = await this.readFile();\r\n    if (!images?.items) {\r\n      throw new Error('ImagesService: updateItems -> Unable to load index');\r\n    }\r\n\r\n    const updatedItems = this.prepareUpdatedItems(items, images.items);\r\n    await this.moveItemFiles(updatedItems);\r\n    const updatedData = this.replaceUpdatedItems(images, updatedItems);\r\n\r\n    await this.writeData(updatedData);\r\n    return true;\r\n  }\r\n\r\n  // Get Items to sort into folders\r\n  private async getNewItems(): Promise<Images | undefined> {\r\n    // Get current items\r\n    const imageData = await this.readFile();\r\n    if (!imageData) {\r\n      throw new Error('getNewItems > Index file not loaded');\r\n    }\r\n    return { ...imageData };\r\n  }\r\n\r\n  /**\r\n   * Move files to new directories\r\n   */\r\n  private async moveItemFiles(updatedItems: Image[]): Promise<void> {\r\n    const fileMoved = getImagesFileService().moveItems(updatedItems);\r\n    if (!fileMoved) {\r\n      throw new Error(\r\n        'ImagesService: updateItems -> Unable to move file: ${item.fileName}',\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Prepare updated items by merging with existing data\r\n   */\r\n  private prepareUpdatedItems(\r\n    items: readonly Image[],\r\n    currentItems: readonly Image[],\r\n  ): Image[] {\r\n    return items.map((item: Image) => {\r\n      const currItems = currentItems.filter((x) => x.id === item.id);\r\n\r\n      if (currItems.length === 0) {\r\n        throw new Error(\r\n          `ImagesService: updateItems -> item not found in index: ${item.id}`,\r\n        );\r\n      }\r\n\r\n      if (currItems.length > 1) {\r\n        throw new Error(\r\n          `ImagesService: updateItems -> Duplicate items found: ${item.id}.  Please correct index`,\r\n        );\r\n      }\r\n\r\n      const [currItem] = currItems;\r\n      if (!currItem) {\r\n        throw new Error(\r\n          `ImagesService: updateItems -> Unexpected undefined item`,\r\n        );\r\n      }\r\n\r\n      return {\r\n        ...currItem,\r\n        ...item,\r\n        isNewItem: false,\r\n        originalFolder: currItem.folder,\r\n      } as Image;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Replace updated items in the collection\r\n   */\r\n  private replaceUpdatedItems(images: Images, updatedItems: Image[]): Images {\r\n    const data: Image[] = (images.items ?? [])\r\n      .map((x) => {\r\n        const foundItem = updatedItems.find((y) => y.id === x.id);\r\n        if (foundItem) {\r\n          const { ...rest } = foundItem;\r\n          return cleanUpData<Image>({ ...rest });\r\n        }\r\n        return x;\r\n      })\r\n      .filter(Boolean);\r\n\r\n    return { ...images, items: data };\r\n  }\r\n\r\n  /**\r\n   * Updates the index file with new items.\r\n   * @returns A promise that resolves to a boolean indicating whether the update was successful.\r\n   */\r\n  private async updateIndexWithNewItems(): Promise<boolean> {\r\n    try {\r\n      // Get all images from /images directory\r\n      const images = getImagesFileService().getItemsFromBaseDirectory();\r\n      // Get current items\r\n      const prev = await this.readFile();\r\n      if (!prev) {\r\n        throw new Error('updateIndexWithNewItems > Index file not loaded');\r\n      }\r\n      const currItems: Image[] = prev.items ?? [];\r\n      // Get the items not already in the list\r\n      const newItems = getNewItems(currItems, images) ?? [];\r\n      // Add the the new items to the existing items\r\n      const allItems = [...currItems, ...newItems];\r\n      // Get ids for the new items\r\n      const modifiedItems = getNewIds(allItems);\r\n      // Write back file\r\n      const data = { ...prev, items: modifiedItems };\r\n      await this.writeData(data);\r\n      return true;\r\n    } catch (error) {\r\n      Logger.error(\r\n        `ImagesService: updateIndexWithNewItems -> ${String(error)}`,\r\n      );\r\n      throw new Error('Failed to update index with new items');\r\n    }\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\features\\images\\getFixFileNames.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\features\\images\\getFolders.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\features\\images\\getItems.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\features\\images\\getItemsEdit.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\features\\images\\getListDuplicates.ts","messages":[{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":9,"column":14,"nodeType":"Identifier","messageId":"neverNullish","endLine":9,"endColumn":18}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { createGetHandler } from '../../lib/http/genericHandlers.js';\r\nimport { getImagesService } from '../../utils/ServiceFactory.js';\r\n\r\nexport const getListDuplicates = createGetHandler<{ readonly items: string[] }>(\r\n  {\r\n    errorResponse: { items: [] },\r\n    getData: async () => {\r\n      const data = await getImagesService().listDuplicates();\r\n      return data ?? { items: [] };\r\n    },\r\n    getItemCount: (data) => (Array.isArray(data) ? data.length : 1),\r\n    handlerName: 'Images:getListDuplicates',\r\n    return204OnEmpty: true,\r\n  },\r\n);\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\features\\images\\getReindex.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\features\\images\\getScan.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\features\\images\\imagesUtil.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\features\\images\\patchItems.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\features\\items\\ItemsService.ts","messages":[{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":20,"column":16,"nodeType":"ChainExpression","messageId":"neverNullish","endLine":20,"endColumn":33},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":20,"column":24,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":20,"endColumn":26,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[791,793],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":21,"column":14,"nodeType":"ChainExpression","messageId":"neverNullish","endLine":21,"endColumn":29},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":21,"column":22,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":21,"endColumn":24,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[830,832],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":22,"column":17,"nodeType":"ChainExpression","messageId":"neverNullish","endLine":22,"endColumn":35},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":22,"column":25,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":22,"endColumn":27,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[870,872],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, value is always falsy.","line":29,"column":9,"nodeType":"UnaryExpression","messageId":"alwaysFalsy","endLine":29,"endColumn":15},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":34,"column":7,"nodeType":"ChainExpression","messageId":"neverNullish","endLine":47,"endColumn":9},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":34,"column":18,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":34,"endColumn":20,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[1183,1185],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":35,"column":45,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":35,"endColumn":47,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[1243,1245],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":54,"column":32,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":54,"endColumn":34,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[1739,1741],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":124,"column":29,"nodeType":"ChainExpression","messageId":"neverNullish","endLine":124,"endColumn":40},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":124,"column":33,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":124,"endColumn":35,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[3934,3936],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":139,"column":18,"nodeType":"ChainExpression","messageId":"neverNullish","endLine":139,"endColumn":31},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":139,"column":22,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":139,"endColumn":24,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[4308,4310],"text":"."},"desc":"Remove unnecessary optional chain"}]},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":141,"column":19,"nodeType":"ChainExpression","messageId":"neverNullish","endLine":141,"endColumn":33},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":141,"column":23,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":141,"endColumn":25,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[4373,4375],"text":"."},"desc":"Remove unnecessary optional chain"}]}],"suppressedMessages":[],"errorCount":17,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { Items } from '../../types/Items.js';\r\nimport type { Item , ItemAdd , ItemArtist , ItemEdit , ItemsArtists , ItemsFile } from '@site8/shared';\r\n\r\nimport FilePath from '../../lib/filesystem/FilePath.js';\r\nimport { BaseDataService } from '../../services/BaseDataService.js';\r\nimport { Logger } from '../../utils/logger.js';\r\nimport { getNextId as getNextIdUtil } from '../../utils/objectUtil.js';\r\n\r\nexport class ItemsService extends BaseDataService<ItemsFile> {\r\n  public constructor() {\r\n    super({\r\n      filePath: FilePath.getDataDir('items.json'),\r\n    });\r\n  }\r\n\r\n  // Get all data - returns only items and metadata (not artists)\r\n  public async getAllItems(): Promise<Items | undefined> {\r\n    const fileData = await this.readFile();\r\n    return {\r\n      artists: fileData?.artists ?? [],\r\n      items: fileData?.items ?? [],\r\n      metadata: fileData?.metadata ?? { title: 'items' },\r\n    };\r\n  }\r\n\r\n  public async getItemsArtists(): Promise<ItemsArtists | undefined> {\r\n    // Get current items\r\n    const items = await this.readFile();\r\n    if (!items) {\r\n      throw new Error('Item file not loaded');\r\n    }\r\n\r\n    const ret: ItemArtist[] =\r\n      items.items?.map((x) => {\r\n        const matchingArtist = items.artists?.find((y) => x.id === y.id);\r\n        if (matchingArtist) {\r\n          return {\r\n            ...x,\r\n            ...matchingArtist,\r\n          };\r\n        }\r\n        return {\r\n          ...x,\r\n          name: 'unknown',\r\n          sortName: 'unknown',\r\n        };\r\n      }) ?? [];\r\n    return { items: ret, metadata: items.metadata };\r\n  }\r\n\r\n  public override async getNextId(): Promise<number | undefined> {\r\n    try {\r\n      const data = await this.readFile();\r\n      return getNextIdUtil(data?.items);\r\n    } catch (error) {\r\n      const errorMessage =\r\n        error instanceof Error ? error.message : String(error);\r\n      Logger.error(`ItemsService: getNextId -> ${errorMessage}`);\r\n      return undefined;\r\n    }\r\n  }\r\n\r\n  public patchItems(_items: readonly ItemEdit[]): boolean {\r\n    //    const itemsTemp = await this.readFile();\r\n\r\n    // Get the updated records\r\n    // const updatedItems: ItemEdit[] = items.map((item) => {\r\n    //   const currItems = itemsTemp.items?.filter((x) => x.id === item.id);\r\n\r\n    //   if (!currItems) {\r\n    //     throw new Error(\r\n    //       `ItemsService: updateItems -> item not found in index: ${item.id}`,\r\n    //     );\r\n    //   }\r\n\r\n    //   if (currItems && currItems?.length > 1) {\r\n    //     throw new Error(\r\n    //       `ItemsService: updateItems -> Duplicate items found: ${item.id}.  Please correct index`,\r\n    //     );\r\n    //   }\r\n\r\n    //   // Create a replacement item\r\n    //   const currItem = currItems[0];\r\n    //   if (currItem) {\r\n    //     return {\r\n    //       ...currItem,\r\n    //       ...item,\r\n    //       isNewItem: false,\r\n    //     };\r\n    //   }\r\n    // });\r\n\r\n    // // Replace the changed records in the original data\r\n    // const data: Item[] = itemsTemp.items\r\n    //   .map((x) => {\r\n    //     const foundItem = updatedItems.find((y) => y.id === x.id);\r\n    //     const addItem = () => {\r\n    //       if (foundItem) {\r\n    //         const { ...rest } = foundItem;\r\n    //         return cleanUpData<Item>({ ...rest });\r\n    //       }\r\n    //       return undefined;\r\n    //     };\r\n    //     const newItem = addItem();\r\n    //     return newItem || x;\r\n    //   })\r\n    //   .filter(Boolean);\r\n\r\n    // const results = await this.writeFile({ ...itemsTemp, items: data });\r\n    // if (!results) {\r\n    //   throw new Error('ItemsService: updateItems -> Failed to update index.');\r\n    // }\r\n\r\n    return true;\r\n  }\r\n\r\n  public async putItems(items: readonly ItemAdd[]): Promise<boolean> {\r\n    try {\r\n      if (!Array.isArray(items)) {\r\n        throw new Error('Put Items failed. Data is not an array');\r\n      }\r\n\r\n      const data = await this.readFile();\r\n      const existingItems = data?.items ?? [];\r\n\r\n      const newItems = await Promise.all(\r\n        items.map(async (item) => {\r\n          const id = (await this.getNextId()) ?? 1;\r\n          return {\r\n            ...item,\r\n            id,\r\n          } as Item;\r\n        }),\r\n      );\r\n\r\n      const updates: Item[] = [...existingItems, ...newItems];\r\n\r\n      await this.writeData({\r\n        artists: data?.artists ?? [],\r\n        items: updates,\r\n        metadata: data?.metadata ?? { title: 'Items' },\r\n      } as ItemsFile);\r\n      return true;\r\n    } catch (error) {\r\n      const errorMessage =\r\n        error instanceof Error ? error.message : String(error);\r\n      Logger.error(`ItemsService: Put Items -> ${errorMessage}`);\r\n      throw new Error(`Put Items failed. Error: ${errorMessage}`);\r\n    }\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\features\\items\\getItems.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\features\\items\\getItemsArtists.ts","messages":[{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.","line":12,"column":27,"nodeType":"ChainExpression","messageId":"neverNullish","endLine":12,"endColumn":45},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary optional chain on a non-nullish value.","line":12,"column":37,"nodeType":"MemberExpression","messageId":"neverOptionalChain","endLine":12,"endColumn":39,"suggestions":[{"messageId":"suggestRemoveOptionalChain","fix":{"range":[530,532],"text":"."},"desc":"Remove unnecessary optional chain"}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { Items } from '../../types/Items.js';\r\n\r\nimport { createGetHandler } from '../../lib/http/genericHandlers.js';\r\nimport { getItemsService } from '../../utils/ServiceFactory.js';\r\n\r\nexport const getItemsArtists = createGetHandler<Items>({\r\n  errorResponse: { artists: [], items: [], metadata: { title: 'Items' } },\r\n  getData: async () => {\r\n    const data = await getItemsService().getAllItems();\r\n    return data ?? { artists: [], items: [], metadata: { title: 'Items' } };\r\n  },\r\n  getItemCount: (data) => data.items?.length ?? 0,\r\n  handlerName: 'Items:getItemsArtists',\r\n  return204OnEmpty: true,\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\features\\items\\patchItems.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\features\\items\\putItems.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\features\\menu\\MenuService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\features\\menu\\getItems.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\features\\menu\\mapPageMenuToMenuItem.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\features\\music\\MusicService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\features\\music\\getItems.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\features\\page\\PageFileService.ts","messages":[{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found existsSync from package \"fs\" with non literal argument at index 0","line":29,"column":11,"nodeType":"CallExpression","endLine":29,"endColumn":31},{"ruleId":"n/no-sync","severity":1,"message":"Unexpected sync method: 'existsSync'.","line":29,"column":11,"nodeType":"CallExpression","messageId":"noSync","endLine":29,"endColumn":31},{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found unlink from package \"fs/promises\" with non literal argument at index 0","line":30,"column":15,"nodeType":"CallExpression","endLine":30,"endColumn":31},{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found existsSync from package \"fs\" with non literal argument at index 0","line":51,"column":12,"nodeType":"CallExpression","endLine":51,"endColumn":32},{"ruleId":"n/no-sync","severity":1,"message":"Unexpected sync method: 'existsSync'.","line":51,"column":12,"nodeType":"CallExpression","messageId":"noSync","endLine":51,"endColumn":32},{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found readFile from package \"fs/promises\" with non literal argument at index 0","line":57,"column":20,"nodeType":"CallExpression","endLine":57,"endColumn":46},{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found writeFile from package \"fs/promises\" with non literal argument at index 0","line":87,"column":13,"nodeType":"CallExpression","endLine":90,"endColumn":9}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { existsSync } from 'fs';\r\nimport { readFile, unlink, writeFile } from 'fs/promises';\r\n\r\nimport FilePath from '../../lib/filesystem/FilePath.js';\r\nimport { Logger } from '../../utils/logger.js';\r\n\r\nexport class PageFileService {\r\n  public async addFile(id: number, text: string | undefined): Promise<boolean> {\r\n    Logger.info('PageFileService: addFile');\r\n\r\n    if (text === undefined) {\r\n      throw new Error('addFile - Text is required');\r\n    }\r\n\r\n    await this.saveFile(id, text);\r\n    return true;\r\n  }\r\n\r\n  public async deleteFile(id: number): Promise<void> {\r\n    Logger.info('PageFileService: deleteFile');\r\n\r\n    const filePath = this.getFileName(id);\r\n\r\n    if (id === 0) {\r\n      throw new Error('deleteFile - ID is required');\r\n    }\r\n\r\n    try {\r\n      if (existsSync(filePath)) {\r\n        await unlink(filePath);\r\n      } else {\r\n        throw new Error(`deleteFile - File does not exist: ${filePath}`);\r\n      }\r\n    } catch (error) {\r\n      const errorMessage =\r\n        error instanceof Error ? error.message : String(error);\r\n      Logger.error(`PageFileService: Error deleting file - ${errorMessage}`, {\r\n        error,\r\n        filePath,\r\n      });\r\n      Logger.error(`Failed to delete file: ${filePath}`);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  public async getFile(id: number): Promise<string> {\r\n    Logger.info(`PageFileService: getFile id: ${id}`);\r\n\r\n    try {\r\n      const filePath = this.getFileName(id);\r\n      if (!existsSync(filePath)) {\r\n        Logger.warn(\r\n          `PageFileService: File does not exist for id ${id}, returning empty content`,\r\n        );\r\n        return '';\r\n      }\r\n      return await readFile(filePath, 'utf8');\r\n    } catch (error) {\r\n      const errorMessage =\r\n        error instanceof Error ? error.message : String(error);\r\n      Logger.error(\r\n        `PageFileService: Error reading file id ${id} - ${errorMessage}`,\r\n        error,\r\n      );\r\n      return '';\r\n    }\r\n  }\r\n\r\n  public async updateFile(\r\n    id: number,\r\n    text: string | undefined,\r\n  ): Promise<boolean> {\r\n    Logger.info('PageFileService: updateFile');\r\n    await this.saveFile(id, text ?? '');\r\n    return true;\r\n  }\r\n\r\n  private getFileName(id: number): string {\r\n    return FilePath.getPagesDir(`page${id.toString()}-en.txt`);\r\n  }\r\n\r\n  // https://nodejs.org/api/fs.html#file-system-flags\r\n  // 'w': Open file for writing. The file is created (if it does not exist) or truncated (if it exists).\r\n  private async saveFile(id: number, text: string): Promise<boolean> {\r\n    try {\r\n      Logger.info(`PageFileService: saveFile id: ${id}`);\r\n      await writeFile(this.getFileName(id), text, {\r\n        encoding: 'utf8',\r\n        flag: 'w',\r\n      });\r\n      return true;\r\n    } catch (error) {\r\n      const errorMessage =\r\n        error instanceof Error ? error.message : String(error);\r\n      Logger.error(\r\n        `PageFileService: Error saving file id ${id} - ${errorMessage}`,\r\n        error,\r\n      );\r\n      throw new Error(`Unable to save file for id: ${id}`);\r\n    }\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\features\\page\\PageService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\features\\page\\deleteItem.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\features\\page\\getItem.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\features\\page\\mapPageMenuToPageText.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\features\\page\\patchItem.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\features\\page\\putItem.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\features\\pages\\PagesService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\features\\pages\\fixEntries.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\features\\pages\\getItems.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\features\\pages\\listDuplicates.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\features\\photos\\PhotosService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\features\\photos\\getItems.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\features\\tests\\TestsService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\features\\tests\\getItems.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\features\\travel\\PlacesMenuService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\features\\travel\\TravelService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\features\\travel\\getItems.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\features\\travel\\getMenu.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\lib\\filesystem\\FilePath.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\lib\\filesystem\\FileService.ts","messages":[{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found existsSync from package \"node:fs\" with non literal argument at index 0","line":12,"column":11,"nodeType":"CallExpression","endLine":12,"endColumn":33},{"ruleId":"n/no-sync","severity":1,"message":"Unexpected sync method: 'existsSync'.","line":12,"column":11,"nodeType":"CallExpression","messageId":"noSync","endLine":12,"endColumn":33},{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found mkdirSync from package \"node:fs\" with non literal argument at index 0","line":15,"column":7,"nodeType":"CallExpression","endLine":15,"endColumn":49},{"ruleId":"n/no-sync","severity":1,"message":"Unexpected sync method: 'mkdirSync'.","line":15,"column":7,"nodeType":"CallExpression","messageId":"noSync","endLine":15,"endColumn":49},{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found realpathSync from package \"node:fs\" with non literal argument at index 0","line":31,"column":28,"nodeType":"CallExpression","endLine":31,"endColumn":50},{"ruleId":"n/no-sync","severity":1,"message":"Unexpected sync method: 'realpathSync'.","line":31,"column":28,"nodeType":"CallExpression","messageId":"noSync","endLine":31,"endColumn":50},{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found readFile from package \"node:fs/promises\" with non literal argument at index 0","line":38,"column":20,"nodeType":"CallExpression","endLine":38,"endColumn":60},{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found realpathSync from package \"node:fs\" with non literal argument at index 0","line":53,"column":28,"nodeType":"CallExpression","endLine":53,"endColumn":50},{"ruleId":"n/no-sync","severity":1,"message":"Unexpected sync method: 'realpathSync'.","line":53,"column":28,"nodeType":"CallExpression","messageId":"noSync","endLine":53,"endColumn":50},{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found realpathSync from package \"node:fs\" with non literal argument at index 0","line":54,"column":26,"nodeType":"CallExpression","endLine":54,"endColumn":63},{"ruleId":"n/no-sync","severity":1,"message":"Unexpected sync method: 'realpathSync'.","line":54,"column":26,"nodeType":"CallExpression","messageId":"noSync","endLine":54,"endColumn":63},{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found readFile from package \"node:fs/promises\" with non literal argument at index 0","line":63,"column":20,"nodeType":"CallExpression","endLine":63,"endColumn":64},{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found readFile from package \"node:fs/promises\" with non literal argument at index 0","line":76,"column":26,"nodeType":"CallExpression","endLine":76,"endColumn":66},{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found writeFile from package \"node:fs/promises\" with non literal argument at index 0","line":89,"column":13,"nodeType":"CallExpression","endLine":91,"endColumn":9},{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found writeFileSync from package \"node:fs\" with non literal argument at index 0","line":104,"column":7,"nodeType":"CallExpression","endLine":107,"endColumn":9},{"ruleId":"n/no-sync","severity":1,"message":"Unexpected sync method: 'writeFileSync'.","line":104,"column":7,"nodeType":"CallExpression","messageId":"noSync","endLine":107,"endColumn":9}],"suppressedMessages":[{"ruleId":"perfectionist/sort-imports","severity":2,"message":"Missed spacing between \"../../utils/logger.js\" and \"./FilePath.js\".","line":6,"column":1,"nodeType":"ImportDeclaration","messageId":"missedSpacingBetweenImports","endLine":6,"endColumn":38,"fix":{"range":[185,187],"text":"\r\n\n"},"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":16,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { existsSync, mkdirSync, realpathSync, writeFileSync } from 'node:fs';\r\nimport { readFile, writeFile } from 'node:fs/promises';\r\n\r\nimport { Logger } from '../../utils/logger.js';\r\n/* eslint-disable-next-line perfectionist/sort-imports */\r\nimport FilePath from './FilePath.js';\r\n\r\nexport class FileService {\r\n  public createFolder(folderPath: string): boolean {\r\n    Logger.info(`FileService: createFolder -> ${folderPath}`);\r\n    try {\r\n      if (existsSync(folderPath)) {\r\n        return true;\r\n      }\r\n      mkdirSync(folderPath, { recursive: true });\r\n      return true;\r\n    } catch (error) {\r\n      const errorMessage =\r\n        error instanceof Error ? error.message : String(error);\r\n      Logger.error(\r\n        `FileService: createFolder: ${folderPath} --> Error: ${errorMessage}`,\r\n      );\r\n      throw new Error(`Create folder failed. Error: ${errorMessage}`);\r\n    }\r\n  }\r\n\r\n  public async getDataFile(fileName: string): Promise<string | undefined> {\r\n    Logger.info(`FileService: getDataFile -> ${fileName}`);\r\n    try {\r\n      const filePath = FilePath.getDataDir(fileName);\r\n      const resolvedPath = realpathSync(filePath);\r\n      if (!resolvedPath.startsWith(__dirname)) {\r\n        Logger.error(\r\n          `FileService: getDataFile: ${fileName} --> Invalid file path: ${filePath}`,\r\n        );\r\n        return undefined;\r\n      }\r\n      return await readFile(filePath, { encoding: 'utf8' });\r\n    } catch (error) {\r\n      const errorMessage =\r\n        error instanceof Error ? error.message : String(error);\r\n      Logger.error(\r\n        `FileService: getDataFile: ${fileName} --> Error: ${errorMessage}`,\r\n      );\r\n      return undefined;\r\n    }\r\n  }\r\n\r\n  public async getFile(filePath: string): Promise<string | undefined> {\r\n    Logger.info(`FileService: getFile -> ${filePath}`);\r\n    try {\r\n      // Prevent path traversal attacks\r\n      const resolvedPath = realpathSync(filePath);\r\n      const allowedDir = realpathSync(FilePath.getDataDir(''));\r\n\r\n      if (!resolvedPath.startsWith(allowedDir)) {\r\n        Logger.error(\r\n          `FileService: getFile: ${filePath} --> Invalid file path attempt: ${resolvedPath}`,\r\n        );\r\n        throw new Error('Access denied: Invalid file path');\r\n      }\r\n\r\n      return await readFile(resolvedPath, { encoding: 'utf8' });\r\n    } catch (error) {\r\n      const errorMessage =\r\n        error instanceof Error ? error.message : String(error);\r\n      Logger.error(\r\n        `FileService: getFile: ${filePath} --> Error: ${errorMessage}`,\r\n      );\r\n      return undefined;\r\n    }\r\n  }\r\n\r\n  public async readFile<T>(filePath: string): Promise<T> {\r\n    try {\r\n      const data = await readFile(filePath, { encoding: 'utf8' });\r\n      return JSON.parse(data) as T;\r\n    } catch (error) {\r\n      const errorMessage =\r\n        error instanceof Error ? error.message : String(error);\r\n      Logger.error(`FileService: readFile -> ${errorMessage}`);\r\n      throw new Error(`Read file failed. Error: ${errorMessage}`);\r\n    }\r\n  }\r\n\r\n  public async writeFile(data: unknown, filePath: string): Promise<boolean> {\r\n    try {\r\n      Logger.info(`FileService: writeFile -> ${filePath}`);\r\n      await writeFile(filePath, JSON.stringify(data, null, 2), {\r\n        encoding: 'utf8',\r\n      });\r\n      return true;\r\n    } catch (error) {\r\n      const errorMessage =\r\n        error instanceof Error ? error.message : String(error);\r\n      Logger.error(`FileService: writeFile -> Error: ${errorMessage}`);\r\n      throw new Error(`Write file failed. Error: ${errorMessage}`);\r\n    }\r\n  }\r\n\r\n  public writeFileSync(data: unknown, filePath: string): boolean {\r\n    try {\r\n      Logger.info(`FileService: writeFileSync -> ${filePath}`);\r\n      writeFileSync(filePath, JSON.stringify(data, null, 2), {\r\n        encoding: 'utf8',\r\n        flag: 'w',\r\n      });\r\n      return true;\r\n    } catch (error) {\r\n      const errorMessage =\r\n        error instanceof Error ? error.message : String(error);\r\n      Logger.error(`FileService: writeFileSync -> Error: ${errorMessage}`);\r\n      throw new Error(`Write file failed. Error: ${errorMessage}`);\r\n    }\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\lib\\filesystem\\getFile.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\lib\\generic\\GenericService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\lib\\generic\\getItem.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\lib\\http\\PreferHeaderHandler.ts","messages":[{"ruleId":"@typescript-eslint/no-extraneous-class","severity":2,"message":"Unexpected class with only static properties.","line":9,"column":14,"nodeType":"Identifier","messageId":"onlyStatic","endLine":9,"endColumn":33}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { Request } from 'express';\r\n\r\nimport { PREFER_HEADER } from '../../utils/constants.js';\r\n\r\n/**\r\n * Handles Prefer header logic for HTTP requests\r\n * Supports RFC 7240 Prefer header patterns\r\n */\r\nexport class PreferHeaderHandler {\r\n  /**\r\n   * Gets the Prefer header value from the request\r\n   * @param req - Express request object\r\n   * @returns Prefer header value or undefined\r\n   */\r\n  public static getPreferHeader(req: Request): string | undefined {\r\n    return req.get('Prefer');\r\n  }\r\n\r\n  /**\r\n   * Checks if the Prefer header requests full representation in response\r\n   * @param req - Express request object\r\n   * @returns True if client prefers full representation (return=representation)\r\n   */\r\n  public static wantsRepresentation(req: Request): boolean {\r\n    const prefer = req.get('Prefer');\r\n    return prefer === PREFER_HEADER.REPRESENTATION;\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\lib\\http\\RequestValidator.ts","messages":[{"ruleId":"@typescript-eslint/no-extraneous-class","severity":2,"message":"Unexpected class with only static properties.","line":19,"column":14,"nodeType":"Identifier","messageId":"onlyStatic","endLine":19,"endColumn":30},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":33,"column":11,"nodeType":"MemberExpression","endLine":33,"endColumn":27},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":33,"column":38,"nodeType":"MemberExpression","endLine":33,"endColumn":54},{"ruleId":"security/detect-object-injection","severity":1,"message":"Function Call Object Injection Sink","line":34,"column":28,"nodeType":"MemberExpression","endLine":34,"endColumn":44},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":41,"column":9,"nodeType":"MemberExpression","endLine":41,"endColumn":25},{"ruleId":"@typescript-eslint/no-unnecessary-condition","severity":2,"message":"Unnecessary conditional, the types have no overlap.","line":163,"column":33,"nodeType":"BinaryExpression","messageId":"noOverlapBooleanExpression","endLine":163,"endColumn":48}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { Request } from 'express';\r\nimport type { ZodType } from 'zod';\r\n\r\n/**\r\n * Result of request validation\r\n */\r\nexport type ValidationResult<T> = {\r\n  /** Validated data if successful */\r\n  data?: T;\r\n  /** Error message if validation failed */\r\n  errorMessage?: string;\r\n  /** Whether validation was successful */\r\n  isValid: boolean;\r\n};\r\n\r\n/**\r\n * Handles request validation using Zod schemas\r\n */\r\nexport class RequestValidator {\r\n  /**\r\n   * Converts string ID fields to numbers in the data object\r\n   * @param data - Data object with potential string IDs\r\n   * @param idFields - Array of field names that should be numbers\r\n   * @returns Result with converted data or error message\r\n   */\r\n  public static convertIdsToNumbers<T extends Record<string, unknown>>(\r\n    data: T,\r\n    idFields: string[] = ['id', 'itemId'],\r\n  ): ValidationResult<T> {\r\n    const converted = { ...data } as Record<string, unknown>;\r\n\r\n    for (const field of idFields) {\r\n      if (converted[field] && typeof converted[field] === 'string') {\r\n        const num = Number(converted[field]);\r\n        if (isNaN(num)) {\r\n          return {\r\n            errorMessage: `${field} must be a valid number`,\r\n            isValid: false,\r\n          };\r\n        }\r\n        converted[field] = num;\r\n      }\r\n    }\r\n\r\n    return {\r\n      data: converted as T,\r\n      isValid: true,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Validates request body against a Zod schema\r\n   * @param req - Express request object\r\n   * @param schema - Zod schema to validate against\r\n   * @returns Validation result with data or error message\r\n   */\r\n  public static validateBody<T>(\r\n    req: Request,\r\n    schema: ZodType<T>,\r\n  ): ValidationResult<T> {\r\n    const validationResult = schema.safeParse(req.body);\r\n\r\n    if (!validationResult.success) {\r\n      const errorMessage = validationResult.error.issues\r\n        .map((err) => `${err.path.join('.')}: ${err.message}`)\r\n        .join(', ');\r\n\r\n      return {\r\n        errorMessage: `Validation error: ${errorMessage}`,\r\n        isValid: false,\r\n      };\r\n    }\r\n\r\n    return {\r\n      data: validationResult.data,\r\n      isValid: true,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Validates request body with additional data merged in\r\n   * @param req - Express request object\r\n   * @param schema - Zod schema to validate against\r\n   * @param additionalData - Additional data to merge with request body\r\n   * @returns Validation result with data or error message\r\n   */\r\n  public static validateBodyWithData<T>(\r\n    req: Request,\r\n    schema: ZodType<T>,\r\n    additionalData: Record<string, unknown>,\r\n  ): ValidationResult<T> {\r\n    const requestData = {\r\n      ...(req.body as Record<string, unknown>),\r\n      ...additionalData,\r\n    };\r\n    const validationResult = schema.safeParse(requestData);\r\n\r\n    if (!validationResult.success) {\r\n      const errorMessage = validationResult.error.issues\r\n        .map((err) => `${err.path.join('.')}: ${err.message}`)\r\n        .join(', ');\r\n\r\n      return {\r\n        errorMessage: `Validation error: ${errorMessage}`,\r\n        isValid: false,\r\n      };\r\n    }\r\n\r\n    return {\r\n      data: validationResult.data,\r\n      isValid: true,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Validates and parses ID from request body\r\n   * @param body - Request body containing id field\r\n   * @returns Validation result with parsed ID number or error message\r\n   */\r\n  public static validateId(\r\n    body: unknown,\r\n  ): ValidationResult<void> & { id?: number } {\r\n    if (!body || typeof body !== 'object' || !('id' in body)) {\r\n      return {\r\n        errorMessage: 'Invalid ID',\r\n        isValid: false,\r\n      };\r\n    }\r\n\r\n    const { id } = body as { id: unknown };\r\n\r\n    if (!id) {\r\n      return {\r\n        errorMessage: 'Invalid ID',\r\n        isValid: false,\r\n      };\r\n    }\r\n\r\n    const idNum = Number(id);\r\n    if (Number.isNaN(idNum) || idNum <= 0) {\r\n      return {\r\n        errorMessage: 'Invalid ID',\r\n        isValid: false,\r\n      };\r\n    }\r\n\r\n    return {\r\n      id: idNum,\r\n      isValid: true,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Validates that ID in URL matches ID in request body\r\n   * @param urlId - ID from URL parameter\r\n   * @param bodyId - ID from request body\r\n   * @returns Validation result\r\n   */\r\n  public static validateIdConsistency(\r\n    urlId: string,\r\n    bodyId?: string | number,\r\n  ): ValidationResult<void> {\r\n    if (bodyId === undefined || bodyId === null) {\r\n      return { isValid: true };\r\n    }\r\n\r\n    const numUrl = Number(urlId);\r\n    const numBody = Number(bodyId as any);\r\n    if (\r\n      Number.isFinite(numUrl) &&\r\n      Number.isFinite(numBody) &&\r\n      numUrl === numBody\r\n    ) {\r\n      return { isValid: true };\r\n    }\r\n\r\n    return {\r\n      errorMessage: 'ID in request body must match ID in URL',\r\n      isValid: false,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Validates that an ID parameter exists in the request\r\n   * @param req - Express request object\r\n   * @returns Validation result with ID or error message\r\n   */\r\n  public static validateIdParam(req: Request): ValidationResult<string> {\r\n    const { id } = req.params;\r\n\r\n    if (!id) {\r\n      return {\r\n        errorMessage: 'ID parameter is required',\r\n        isValid: false,\r\n      };\r\n    }\r\n\r\n    return {\r\n      data: id,\r\n      isValid: true,\r\n    };\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\lib\\http\\ResponseHelper.ts","messages":[{"ruleId":"@typescript-eslint/no-extraneous-class","severity":2,"message":"Unexpected class with only static properties.","line":9,"column":14,"nodeType":"Identifier","messageId":"onlyStatic","endLine":9,"endColumn":28}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { Response } from 'express';\r\n\r\nimport { Logger } from '../../utils/logger.js';\r\n\r\n/**\r\n * Standardized response helper for HTTP handlers\r\n * Handles common response patterns and logging\r\n */\r\nexport class ResponseHelper {\r\n  /**\r\n   * Sends a 400 Bad Request response\r\n   * @param res - Express response object\r\n   * @param errorMessage - Error message\r\n   * @param handlerName - Name of the handler for logging\r\n   */\r\n  public static badRequest(\r\n    res: Response<{ error: string }>,\r\n    errorMessage: string,\r\n    handlerName?: string,\r\n  ): void {\r\n    if (handlerName) {\r\n      Logger.warn(`${handlerName}: ${errorMessage}`);\r\n    }\r\n    res.status(400).json({ error: errorMessage });\r\n  }\r\n\r\n  /**\r\n   * Sends a 409 Conflict response\r\n   * @param res - Express response object\r\n   * @param errorMessage - Error message\r\n   */\r\n  public static conflict(\r\n    res: Response<{ error: string }>,\r\n    errorMessage: string,\r\n  ): void {\r\n    res.status(409).json({ error: errorMessage });\r\n  }\r\n\r\n  /**\r\n   * Sends a 201 Created response with optional Location header and data\r\n   * @param res - Express response object\r\n   * @param resourcePath - Resource path for Location header\r\n   * @param id - Created resource ID\r\n   * @param data - Optional data to return\r\n   */\r\n  public static created<T>(\r\n    res: Response<T>,\r\n    resourcePath: string,\r\n    id: number,\r\n    data?: T,\r\n  ): void {\r\n    res.setHeader('Location', `${resourcePath}/${id}`);\r\n\r\n    if (data) {\r\n      res.status(201).json(data);\r\n    } else {\r\n      res.status(201).send();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Sends a 500 Internal Server Error response with generic error data\r\n   * @param res - Express response object\r\n   * @param handlerName - Name of the handler for logging\r\n   * @param error - The error that occurred\r\n   * @param errorResponse - Optional error response data\r\n   */\r\n  public static internalError<T>(\r\n    res: Response<T>,\r\n    handlerName: string,\r\n    error: unknown,\r\n    errorResponse?: T,\r\n  ): void {\r\n    const errorMessage =\r\n      error instanceof Error ? error.message : 'Unknown error occurred';\r\n\r\n    Logger.error(`${handlerName}: Failed to process request`, {\r\n      error: errorMessage,\r\n    });\r\n\r\n    if (errorResponse) {\r\n      res.status(500).json(errorResponse);\r\n    } else {\r\n      res.sendStatus(500);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Checks if service error indicates a duplicate/conflict error\r\n   * @param error - Error to check\r\n   * @returns True if error is a duplicate/conflict error\r\n   */\r\n  public static isConflictError(error: unknown): boolean {\r\n    return (\r\n      error instanceof Error &&\r\n      (error.message.includes('duplicate') ||\r\n        error.message.includes('already exists'))\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Checks if service error indicates a \"not found\" condition\r\n   * @param error - Error to check\r\n   * @returns True if error is a \"not found\" error\r\n   */\r\n  public static isNotFoundError(error: unknown): boolean {\r\n    return error instanceof Error && error.message.includes('not found');\r\n  }\r\n\r\n  /**\r\n   * Checks if service error indicates a validation error\r\n   * @param error - Error to check\r\n   * @returns True if error is a validation error\r\n   */\r\n  public static isValidationError(error: unknown): boolean {\r\n    return error instanceof Error && error.message.includes('validation');\r\n  }\r\n\r\n  /**\r\n   * Sends a 204 No Content response\r\n   * @param res - Express response object\r\n   * @param handlerName - Name of the handler for logging\r\n   * @param reason - Optional reason for 204 (e.g., \"No items found\")\r\n   */\r\n  public static noContent(\r\n    res: Response,\r\n    handlerName: string,\r\n    reason?: string,\r\n  ): void {\r\n    if (reason) {\r\n      Logger.info(`${handlerName}: ${reason}`);\r\n    }\r\n    res.sendStatus(204);\r\n  }\r\n\r\n  /**\r\n   * Sends a 404 Not Found response\r\n   * @param res - Express response object\r\n   * @param errorMessage - Error message\r\n   */\r\n  public static notFound(\r\n    res: Response<{ error: string }>,\r\n    errorMessage = 'Item not found',\r\n  ): void {\r\n    res.status(404).json({ error: errorMessage });\r\n  }\r\n\r\n  /**\r\n   * Sends a 501 Not Implemented response\r\n   * @param res - Express response object\r\n   * @param errorMessage - Error message describing what is not implemented\r\n   */\r\n  public static notImplemented(\r\n    res: Response<{ error: string }>,\r\n    errorMessage = 'Not implemented',\r\n  ): void {\r\n    Logger.warn(`Not Implemented: ${errorMessage}`);\r\n    res.status(501).json({ error: errorMessage });\r\n  }\r\n\r\n  /**\r\n   * Sends a 200 OK response with data\r\n   * @param res - Express response object\r\n   * @param data - Data to send\r\n   * @param handlerName - Name of the handler for logging\r\n   * @param itemCount - Optional item count for logging\r\n   */\r\n  public static ok<T>(\r\n    res: Response<T>,\r\n    data: T,\r\n    handlerName: string,\r\n    itemCount?: number,\r\n  ): void {\r\n    if (itemCount !== undefined) {\r\n      Logger.info(`${handlerName}: Successfully retrieved ${itemCount} items`);\r\n    } else {\r\n      Logger.info(`${handlerName}: Successfully retrieved data`);\r\n    }\r\n\r\n    res.status(200).json(data);\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\lib\\http\\createCollectionHandler.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\lib\\http\\genericHandlers.ts","messages":[{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":220,"column":40,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":220,"endColumn":64},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":229,"column":40,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":229,"endColumn":66},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":232,"column":14,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":232,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":235,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":235,"endColumn":33},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":247,"column":15,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":250,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .patchItem on an `any` value.","line":248,"column":35,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":248,"endColumn":44},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .patchItem on an `any` value.","line":249,"column":38,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":249,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `number`.","line":253,"column":48,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":253,"endColumn":57},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":310,"column":40,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":310,"endColumn":64},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":314,"column":20,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":314,"endColumn":36},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":388,"column":40,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":388,"endColumn":64},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":392,"column":20,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":392,"endColumn":36},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":440,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":440,"endColumn":30}],"suppressedMessages":[],"errorCount":13,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { Request, Response } from 'express';\r\nimport type { ZodType } from 'zod';\r\n\r\nimport { Logger } from '../../utils/logger.js';\r\n\r\nimport { PreferHeaderHandler } from './PreferHeaderHandler.js';\r\nimport { RequestValidator } from './RequestValidator.js';\r\nimport { ResponseHelper } from './ResponseHelper.js';\r\n\r\n/**\r\n * Configuration for creating a generic GET handler without parameters\r\n */\r\ntype GetHandlerConfig<T> = {\r\n  /** Default response for errors */\r\n  errorResponse: T;\r\n  /** Function that retrieves the data */\r\n  getData: () => Promise<T>;\r\n  /** Function to extract item count from the response (optional) */\r\n  getItemCount?: (data: T) => number;\r\n  /** Name of the handler for logging purposes */\r\n  handlerName: string;\r\n  /** Whether to return 204 when no items found (default: false) */\r\n  return204OnEmpty?: boolean;\r\n};\r\n\r\n/**\r\n * Configuration for creating a generic GET handler with request parameters\r\n */\r\ntype GetHandlerWithParamsConfig<T> = {\r\n  /** Default response for errors */\r\n  errorResponse: T;\r\n  /** Function that retrieves the data using request object */\r\n  getData: (req: Request) => Promise<T>;\r\n  /** Function to extract item count from the response (optional) */\r\n  getItemCount?: (data: T) => number;\r\n  /** Name of the handler for logging purposes */\r\n  handlerName: string;\r\n  /** Whether to return 204 when no items found (default: false) */\r\n  return204OnEmpty?: boolean;\r\n  /** Function to validate request parameters (optional) */\r\n  validateParams?: (req: Request) => {\r\n    errorMessage?: string;\r\n    isValid: boolean;\r\n  };\r\n};\r\n\r\ntype PatchOptions<T> = {\r\n  getService: () => {\r\n    getItem: (id: number) => Promise<T | undefined>;\r\n    updateItem: (data: T) => Promise<number>;\r\n  };\r\n  idFields?: string[];\r\n  schema: ZodType<any>;\r\n  serviceName: string;\r\n};\r\n\r\ntype DeleteOptions<T> = {\r\n  getService: () => {\r\n    deleteItem: (id: number) => Promise<T | undefined>;\r\n  };\r\n  returnDeleted?: boolean;\r\n  serviceName: string;\r\n};\r\n\r\n/**\r\n * Creates a generic GET handler for Express routes\r\n * @template T - The response type\r\n * @param config - Configuration for the handler\r\n * @returns Express request handler\r\n *\r\n * @example\r\n * ```typescript\r\n * export const getArtists = createGetHandler<Artists>({\r\n *   handlerName: 'getArtists',\r\n *   getData: async () => {\r\n *     const service = getArtistsService();\r\n *     return service.getArtists();\r\n *   },\r\n *   getItemCount: (data) => data.items?.length ?? 0,\r\n *   return204OnEmpty: true,\r\n *   errorResponse: {\r\n *     items: undefined,\r\n *     metadata: { title: 'Artists' },\r\n *   },\r\n * });\r\n * ```\r\n */\r\nexport const createGetHandler = <T>(config: GetHandlerConfig<T>) => {\r\n  const {\r\n    errorResponse,\r\n    getData,\r\n    getItemCount,\r\n    handlerName,\r\n    return204OnEmpty = false,\r\n  } = config;\r\n\r\n  return async (_req: Request, res: Response<T>): Promise<void> => {\r\n    try {\r\n      Logger.info(`${handlerName}: Retrieving data`);\r\n\r\n      const data = await getData();\r\n\r\n      // Check for empty results if configured\r\n      if (getItemCount && return204OnEmpty) {\r\n        const itemCount = getItemCount(data);\r\n\r\n        if (itemCount === 0) {\r\n          ResponseHelper.noContent(res, handlerName, 'No items found');\r\n          return;\r\n        }\r\n\r\n        ResponseHelper.ok(res, data, handlerName, itemCount);\r\n      } else {\r\n        ResponseHelper.ok(res, data, handlerName);\r\n      }\r\n    } catch (error) {\r\n      ResponseHelper.internalError(res, handlerName, error, errorResponse);\r\n    }\r\n  };\r\n};\r\n\r\n/**\r\n * Creates a generic GET handler for Express routes that requires request parameters\r\n * @template T - The response type\r\n * @param config - Configuration for the handler with request parameter support\r\n * @returns Express request handler\r\n *\r\n * @example\r\n * ```typescript\r\n * export const getItemsPage = createGetHandlerWithParams<Bookmarks>({\r\n *   handlerName: 'getItemsPage',\r\n *   getData: async (req) => {\r\n *     const { id } = req.params;\r\n *     const service = getBookmarksService();\r\n *     const result = await service.getBookmarksForPage(id);\r\n *     return result ?? { items: [], metadata: { title: 'Bookmarks' } };\r\n *   },\r\n *   validateParams: (req) => {\r\n *     const { id } = req.params;\r\n *     if (!id) {\r\n *       return { isValid: false, errorMessage: 'Missing page id parameter' };\r\n *     }\r\n *     return { isValid: true };\r\n *   },\r\n *   getItemCount: (data) => data.items.length,\r\n *   return204OnEmpty: true,\r\n *   errorResponse: {\r\n *     items: [],\r\n *     metadata: { title: 'Bookmarks' },\r\n *   },\r\n * });\r\n * ```\r\n */\r\nexport const createGetHandlerWithParams = <T>(\r\n  config: GetHandlerWithParamsConfig<T>,\r\n) => {\r\n  const {\r\n    errorResponse,\r\n    getData,\r\n    getItemCount,\r\n    handlerName,\r\n    return204OnEmpty = false,\r\n    validateParams,\r\n  } = config;\r\n\r\n  return async (req: Request, res: Response<T>): Promise<void> => {\r\n    try {\r\n      // Validate parameters if validator is provided\r\n      if (validateParams) {\r\n        const validation = validateParams(req);\r\n        if (!validation.isValid) {\r\n          ResponseHelper.badRequest(\r\n            res as Response<{ error: string }>,\r\n            validation.errorMessage ?? 'Invalid parameters',\r\n            handlerName,\r\n          );\r\n          return;\r\n        }\r\n      }\r\n\r\n      Logger.info(`${handlerName}: Retrieving data`);\r\n\r\n      const data = await getData(req);\r\n\r\n      // Check for empty results if configured\r\n      if (getItemCount && return204OnEmpty) {\r\n        const itemCount = getItemCount(data);\r\n\r\n        if (itemCount === 0) {\r\n          ResponseHelper.noContent(res, handlerName, 'No items found');\r\n          return;\r\n        }\r\n\r\n        ResponseHelper.ok(res, data, handlerName, itemCount);\r\n      } else {\r\n        ResponseHelper.ok(res, data, handlerName);\r\n      }\r\n    } catch (error) {\r\n      ResponseHelper.internalError(res, handlerName, error, errorResponse);\r\n    }\r\n  };\r\n};\r\n\r\nexport const createPatchHandler = <T>({\r\n  getService,\r\n  idFields = ['id', 'itemId'],\r\n  schema,\r\n  serviceName,\r\n}: PatchOptions<T>) => {\r\n  return async (\r\n    req: Request,\r\n    res: Response<T | { error: string }>,\r\n  ): Promise<void> => {\r\n    try {\r\n      const returnRepresentation = PreferHeaderHandler.wantsRepresentation(req);\r\n\r\n      // Validate request body (ID should be in body, not URL)\r\n      const validation = RequestValidator.validateBody(req, schema);\r\n      if (!validation.isValid) {\r\n        ResponseHelper.badRequest(res, validation.errorMessage!);\r\n        return;\r\n      }\r\n\r\n      let data = validation.data as Record<string, unknown>;\r\n\r\n      // Convert string IDs to numbers\r\n      const idConversion = RequestValidator.convertIdsToNumbers(data, idFields);\r\n      if (!idConversion.isValid) {\r\n        ResponseHelper.badRequest(res, idConversion.errorMessage!);\r\n        return;\r\n      }\r\n      data = idConversion.data!;\r\n\r\n      // Validate ID exists in body\r\n      const {id} = (data as any);\r\n      if (!id) {\r\n        ResponseHelper.badRequest(res, 'ID is required in request body');\r\n        return;\r\n      }\r\n\r\n      Logger.info(`${serviceName}: Patch Item called for ID: ${id}`);\r\n\r\n      const service = getService();\r\n\r\n      try {\r\n        // Prefer `patchItem` when available on the service, fall back to `updateItem` for compatibility\r\n        const updatedId =\r\n          typeof (service as any).patchItem === 'function'\r\n            ? await (service as any).patchItem(data as T)\r\n            : await service.updateItem(data as T);\r\n\r\n        if (returnRepresentation) {\r\n          const result = await service.getItem(updatedId);\r\n          if (!result) {\r\n            ResponseHelper.notFound(res, 'Item not found after update');\r\n            return;\r\n          }\r\n          ResponseHelper.ok(res, result, serviceName);\r\n          return;\r\n        }\r\n        ResponseHelper.noContent(res, serviceName);\r\n      } catch (serviceError) {\r\n        if (ResponseHelper.isNotFoundError(serviceError)) {\r\n          ResponseHelper.notFound(res);\r\n          return;\r\n        }\r\n        if (ResponseHelper.isValidationError(serviceError)) {\r\n          ResponseHelper.badRequest(\r\n            res,\r\n            serviceError instanceof Error\r\n              ? serviceError.message\r\n              : 'Validation error',\r\n          );\r\n          return;\r\n        }\r\n        throw serviceError;\r\n      }\r\n    } catch (error) {\r\n      ResponseHelper.internalError(res, serviceName, error);\r\n    }\r\n  };\r\n};\r\n\r\ntype PostOptions<T, TAdd> = {\r\n  getService: () => {\r\n    addItem: (data: TAdd) => Promise<number>;\r\n    getItem: (id: number) => Promise<T | undefined>;\r\n  };\r\n  resourcePath: string;\r\n  schema: ZodType<TAdd>;\r\n  serviceName: string;\r\n};\r\n\r\nexport const createPostHandler = <T, TAdd>({\r\n  getService,\r\n  resourcePath,\r\n  schema,\r\n  serviceName,\r\n}: PostOptions<T, TAdd>) => {\r\n  return async (\r\n    req: Request,\r\n    res: Response<T | { error: string }>,\r\n  ): Promise<void> => {\r\n    try {\r\n      const returnRepresentation = PreferHeaderHandler.wantsRepresentation(req);\r\n\r\n      // Validate request body\r\n      const validation = RequestValidator.validateBody(req, schema);\r\n      if (!validation.isValid) {\r\n        ResponseHelper.badRequest(res, validation.errorMessage!);\r\n        return;\r\n      }\r\n\r\n      const data = validation.data!;\r\n      Logger.info(`${serviceName}: Post Item called (create new)`);\r\n\r\n      const service = getService();\r\n\r\n      try {\r\n        const newId = await service.addItem(data);\r\n\r\n        if (returnRepresentation) {\r\n          const newItem = await service.getItem(newId);\r\n          if (!newItem) {\r\n            ResponseHelper.internalError(\r\n              res,\r\n              serviceName,\r\n              new Error('Failed to retrieve created item'),\r\n            );\r\n            return;\r\n          }\r\n          ResponseHelper.created(res, resourcePath, newId, newItem);\r\n          return;\r\n        }\r\n\r\n        ResponseHelper.created(res, resourcePath, newId);\r\n      } catch (serviceError) {\r\n        if (ResponseHelper.isValidationError(serviceError)) {\r\n          ResponseHelper.badRequest(\r\n            res,\r\n            serviceError instanceof Error\r\n              ? serviceError.message\r\n              : 'Validation error',\r\n          );\r\n          return;\r\n        }\r\n        if (ResponseHelper.isConflictError(serviceError)) {\r\n          ResponseHelper.conflict(\r\n            res,\r\n            serviceError instanceof Error ? serviceError.message : 'Conflict',\r\n          );\r\n          return;\r\n        }\r\n        throw serviceError;\r\n      }\r\n    } catch (error) {\r\n      ResponseHelper.internalError(res, serviceName, error);\r\n    }\r\n  };\r\n};\r\n\r\ntype PutOptions<T, TAdd> = {\r\n  getService: () => {\r\n    addItem: (data: TAdd) => Promise<number>;\r\n    getItem: (id: number) => Promise<T | undefined>;\r\n  };\r\n  resourcePath: string;\r\n  schema: ZodType<TAdd>;\r\n  serviceName: string;\r\n};\r\n\r\nexport const createPutHandler = <T, TAdd>({\r\n  getService,\r\n  resourcePath,\r\n  schema,\r\n  serviceName,\r\n}: PutOptions<T, TAdd>) => {\r\n  return async (\r\n    req: Request,\r\n    res: Response<T | { error: string }>,\r\n  ): Promise<void> => {\r\n    try {\r\n      const returnRepresentation = PreferHeaderHandler.wantsRepresentation(req);\r\n\r\n      // Validate request body\r\n      const validation = RequestValidator.validateBody(req, schema);\r\n      if (!validation.isValid) {\r\n        ResponseHelper.badRequest(res, validation.errorMessage!);\r\n        return;\r\n      }\r\n\r\n      const data = validation.data!;\r\n      Logger.info(`${serviceName}: Put Item called`);\r\n\r\n      const service = getService();\r\n      const newId = await service.addItem(data);\r\n\r\n      if (returnRepresentation) {\r\n        const newItem = await service.getItem(newId);\r\n        if (newItem) {\r\n          ResponseHelper.ok(res, newItem, serviceName);\r\n          return;\r\n        }\r\n        ResponseHelper.notFound(res, 'Created item not found');\r\n        return;\r\n      }\r\n\r\n      ResponseHelper.created(res, resourcePath, newId);\r\n    } catch (error) {\r\n      ResponseHelper.internalError(res, serviceName, error);\r\n    }\r\n  };\r\n};\r\n\r\n/**\r\n * Creates a generic DELETE handler for Express routes\r\n * @template T - The resource type\r\n * @param config - Configuration for the handler\r\n * @returns Express request handler\r\n *\r\n * @example\r\n * ```typescript\r\n * export const deleteItem = createDeleteHandler<Image>({\r\n *   getService: getImageService,\r\n *   serviceName: 'Image',\r\n *   returnDeleted: true,\r\n * });\r\n * ```\r\n */\r\nexport const createDeleteHandler = <T>({\r\n  getService,\r\n  returnDeleted = false,\r\n  serviceName,\r\n}: DeleteOptions<T>) => {\r\n  return async (\r\n    req: Request,\r\n    res: Response<T | { error: string }>,\r\n  ): Promise<void> => {\r\n    try {\r\n      const { id } = req.body;\r\n\r\n      if (!id) {\r\n        ResponseHelper.badRequest(res, 'Invalid ID');\r\n        return;\r\n      }\r\n\r\n      // Parse and validate ID\r\n      const idNum = Number(id);\r\n      if (Number.isNaN(idNum) || idNum <= 0) {\r\n        ResponseHelper.badRequest(res, 'Invalid ID');\r\n        return;\r\n      }\r\n\r\n      Logger.info(`${serviceName}: Delete Item called: ${idNum}`);\r\n\r\n      const service = getService();\r\n      const deletedItem = await service.deleteItem(idNum);\r\n\r\n      if (!deletedItem) {\r\n        ResponseHelper.notFound(res, 'Item not found');\r\n        return;\r\n      }\r\n\r\n      if (returnDeleted) {\r\n        ResponseHelper.ok(res, deletedItem, serviceName);\r\n      } else {\r\n        ResponseHelper.noContent(res, serviceName);\r\n      }\r\n    } catch (error) {\r\n      ResponseHelper.internalError(res, serviceName, error);\r\n    }\r\n  };\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\middleware\\createValidator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\middleware\\requireFileName.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\middleware\\requireId.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\middleware\\requireName.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\middleware\\requireNumericId.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\server.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\services\\BaseDataService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\services\\CacheManager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\services\\DataValidator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\services\\ErrorHandler.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\services\\IDataService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\services\\build\\BuildService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\services\\build\\Features.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\services\\build\\buildFeature.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\services\\build\\functions\\server\\bServerService.ts","messages":[{"ruleId":"n/no-sync","severity":1,"message":"Unexpected sync method: 'writeFileSync'.","line":46,"column":3,"nodeType":"MemberExpression","messageId":"noSync","endLine":46,"endColumn":24}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { FieldType } from '../../Features.js';\r\n\r\nimport path from 'path';\r\n\r\nimport { Logger } from '../../../../utils/logger.js';\r\nimport {\r\n  getFileService,\r\n  getPrettierService,\r\n} from '../../../../utils/ServiceFactory.js';\r\n\r\nexport const buildServerType = async (data: FieldType, targetPath: string) => {\r\n  Logger.debug(`Build Server Service called`);\r\n\r\n  const service = getFileService();\r\n  const prettierService = getPrettierService();\r\n  const ret: string[] = [];\r\n\r\n  // Imports\r\n  ret.push(`import { Logger } from '../../utils/logger.js';`);\r\n  ret.push(`import { cleanUpData } from '../../utils/objectUtil.js';`);\r\n  ret.push(`import { Image } from '../../types/Image.js';`);\r\n  ret.push(`import { Images } from '../../types/Images.js';`);\r\n\r\n  // Function\r\n  ret.push(`export class ImageService {`);\r\n\r\n  // getItem\r\n\r\n  // Fields\r\n  const fields = data.fields.toSorted((a, b) => a.name.localeCompare(b.name));\r\n\r\n  fields.forEach((field) => {\r\n    ret.push(`readonly '${field.name}: ${field.type};`);\r\n  });\r\n\r\n  // End\r\n  ret.push(`};`);\r\n\r\n  // src/types/\r\n  const filePath = path.join(targetPath, data.name + '.ts');\r\n\r\n  Logger.debug(`Build Server Service: ${filePath}`);\r\n\r\n  const formatted = await prettierService.formatCode(ret.join('\\n'), filePath);\r\n\r\n  service.writeFileSync(formatted, filePath);\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\services\\build\\functions\\server\\bServerType.ts","messages":[{"ruleId":"n/no-sync","severity":1,"message":"Unexpected sync method: 'writeFileSync'.","line":38,"column":3,"nodeType":"MemberExpression","messageId":"noSync","endLine":38,"endColumn":24}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { FieldType } from '../../Features.js';\r\n\r\nimport path from 'path';\r\n\r\nimport { Logger } from '../../../../utils/logger.js';\r\nimport {\r\n  getFileService,\r\n  getPrettierService,\r\n} from '../../../../utils/ServiceFactory.js';\r\n\r\nexport const buildServerType = async (data: FieldType, targetPath: string) => {\r\n  Logger.debug(`Build Server Type called`);\r\n\r\n  const service = getFileService();\r\n  const prettierService = getPrettierService();\r\n  const ret: string[] = [];\r\n\r\n  // Start\r\n  ret.push(`export type ${data.name} = {`);\r\n\r\n  const fields = data.fields.toSorted((a, b) => a.name.localeCompare(b.name));\r\n\r\n  fields.forEach((field) => {\r\n    ret.push(`readonly '${field.name}: ${field.type};`);\r\n  });\r\n\r\n  // End\r\n\r\n  ret.push(`};`);\r\n\r\n  // src/types/\r\n  const filePath = path.join(targetPath, data.name + '.ts');\r\n\r\n  Logger.debug(`Build Server Type: ${filePath}`);\r\n\r\n  const formatted = await prettierService.formatCode(ret.join('\\n'), filePath);\r\n\r\n  service.writeFileSync(formatted, filePath);\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\services\\code-quality\\ESLintService.ts","messages":[],"suppressedMessages":[{"ruleId":"import/no-extraneous-dependencies","severity":2,"message":"'eslint' should be listed in the project's dependencies, not devDependencies.","line":2,"column":1,"nodeType":"ImportDeclaration","endLine":2,"endColumn":34,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\services\\code-quality\\PrettierService.ts","messages":[],"suppressedMessages":[{"ruleId":"import/no-extraneous-dependencies","severity":2,"message":"'prettier' should be listed in the project's dependencies, not devDependencies.","line":2,"column":1,"nodeType":"ImportDeclaration","endLine":2,"endColumn":38,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\types\\Items.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\types\\PageText.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\utils\\Environment.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-extraneous-class","severity":2,"message":"Unexpected class with only static properties.","line":4,"column":14,"nodeType":"Identifier","messageId":"onlyStatic","endLine":4,"endColumn":25,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\utils\\ServiceFactory.ts","messages":[],"suppressedMessages":[{"ruleId":"import/no-restricted-paths","severity":2,"message":"Unexpected path \"../features/artists/ArtistsService.js\" imported in restricted zone.","line":14,"column":32,"nodeType":"Literal","endLine":14,"endColumn":71,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"import/no-restricted-paths","severity":2,"message":"Unexpected path \"../features/bookmarks/BookmarksService.js\" imported in restricted zone.","line":15,"column":34,"nodeType":"Literal","endLine":15,"endColumn":77,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"import/no-restricted-paths","severity":2,"message":"Unexpected path \"../features/image/ImageService.js\" imported in restricted zone.","line":16,"column":30,"nodeType":"Literal","endLine":16,"endColumn":65,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"import/no-restricted-paths","severity":2,"message":"Unexpected path \"../features/images/ImagesFileService.js\" imported in restricted zone.","line":17,"column":35,"nodeType":"Literal","endLine":17,"endColumn":76,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"import/no-restricted-paths","severity":2,"message":"Unexpected path \"../features/images/ImagesService.js\" imported in restricted zone.","line":18,"column":31,"nodeType":"Literal","endLine":18,"endColumn":68,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"import/no-restricted-paths","severity":2,"message":"Unexpected path \"../features/items/ItemsService.js\" imported in restricted zone.","line":19,"column":30,"nodeType":"Literal","endLine":19,"endColumn":65,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"import/no-restricted-paths","severity":2,"message":"Unexpected path \"../features/menu/MenuService.js\" imported in restricted zone.","line":20,"column":29,"nodeType":"Literal","endLine":20,"endColumn":62,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"import/no-restricted-paths","severity":2,"message":"Unexpected path \"../features/music/MusicService.js\" imported in restricted zone.","line":21,"column":30,"nodeType":"Literal","endLine":21,"endColumn":65,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"import/no-restricted-paths","severity":2,"message":"Unexpected path \"../features/page/PageFileService.js\" imported in restricted zone.","line":22,"column":33,"nodeType":"Literal","endLine":22,"endColumn":70,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"import/no-restricted-paths","severity":2,"message":"Unexpected path \"../features/page/PageService.js\" imported in restricted zone.","line":23,"column":29,"nodeType":"Literal","endLine":23,"endColumn":62,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"import/no-restricted-paths","severity":2,"message":"Unexpected path \"../features/pages/PagesService.js\" imported in restricted zone.","line":24,"column":30,"nodeType":"Literal","endLine":24,"endColumn":65,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"import/no-restricted-paths","severity":2,"message":"Unexpected path \"../features/photos/PhotosService.js\" imported in restricted zone.","line":25,"column":31,"nodeType":"Literal","endLine":25,"endColumn":68,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"import/no-restricted-paths","severity":2,"message":"Unexpected path \"../features/tests/TestsService.js\" imported in restricted zone.","line":26,"column":30,"nodeType":"Literal","endLine":26,"endColumn":65,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"import/no-restricted-paths","severity":2,"message":"Unexpected path \"../features/travel/PlacesMenuService.js\" imported in restricted zone.","line":27,"column":35,"nodeType":"Literal","endLine":27,"endColumn":76,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"import/no-restricted-paths","severity":2,"message":"Unexpected path \"../features/travel/TravelService.js\" imported in restricted zone.","line":28,"column":31,"nodeType":"Literal","endLine":28,"endColumn":68,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"no-restricted-syntax","severity":2,"message":"Instantiate services via ServiceFactory.get*Service() factory functions instead of using 'new <Service>()'.","line":41,"column":53,"nodeType":"NewExpression","messageId":"restrictedSyntax","endLine":41,"endColumn":73,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"no-restricted-syntax","severity":2,"message":"Instantiate services via ServiceFactory.get*Service() factory functions instead of using 'new <Service>()'.","line":45,"column":55,"nodeType":"NewExpression","messageId":"restrictedSyntax","endLine":45,"endColumn":77,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"no-restricted-syntax","severity":2,"message":"Instantiate services via ServiceFactory.get*Service() factory functions instead of using 'new <Service>()'.","line":49,"column":51,"nodeType":"NewExpression","messageId":"restrictedSyntax","endLine":49,"endColumn":69,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"no-restricted-syntax","severity":2,"message":"Instantiate services via ServiceFactory.get*Service() factory functions instead of using 'new <Service>()'.","line":53,"column":50,"nodeType":"NewExpression","messageId":"restrictedSyntax","endLine":53,"endColumn":67,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"no-restricted-syntax","severity":2,"message":"Instantiate services via ServiceFactory.get*Service() factory functions instead of using 'new <Service>()'.","line":57,"column":53,"nodeType":"NewExpression","messageId":"restrictedSyntax","endLine":57,"endColumn":73,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"no-restricted-syntax","severity":2,"message":"Instantiate services via ServiceFactory.get*Service() factory functions instead of using 'new <Service>()'.","line":61,"column":51,"nodeType":"NewExpression","messageId":"restrictedSyntax","endLine":61,"endColumn":69,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"no-restricted-syntax","severity":2,"message":"Instantiate services via ServiceFactory.get*Service() factory functions instead of using 'new <Service>()'.","line":65,"column":56,"nodeType":"NewExpression","messageId":"restrictedSyntax","endLine":65,"endColumn":79,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"no-restricted-syntax","severity":2,"message":"Instantiate services via ServiceFactory.get*Service() factory functions instead of using 'new <Service>()'.","line":69,"column":52,"nodeType":"NewExpression","messageId":"restrictedSyntax","endLine":69,"endColumn":71,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"no-restricted-syntax","severity":2,"message":"Instantiate services via ServiceFactory.get*Service() factory functions instead of using 'new <Service>()'.","line":73,"column":51,"nodeType":"NewExpression","messageId":"restrictedSyntax","endLine":73,"endColumn":69,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"no-restricted-syntax","severity":2,"message":"Instantiate services via ServiceFactory.get*Service() factory functions instead of using 'new <Service>()'.","line":79,"column":13,"nodeType":"NewExpression","messageId":"restrictedSyntax","endLine":79,"endColumn":52,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"no-restricted-syntax","severity":2,"message":"Instantiate services via ServiceFactory.get*Service() factory functions instead of using 'new <Service>()'.","line":84,"column":51,"nodeType":"NewExpression","messageId":"restrictedSyntax","endLine":84,"endColumn":69,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"no-restricted-syntax","severity":2,"message":"Instantiate services via ServiceFactory.get*Service() factory functions instead of using 'new <Service>()'.","line":88,"column":54,"nodeType":"NewExpression","messageId":"restrictedSyntax","endLine":88,"endColumn":75,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"no-restricted-syntax","severity":2,"message":"Instantiate services via ServiceFactory.get*Service() factory functions instead of using 'new <Service>()'.","line":92,"column":50,"nodeType":"NewExpression","messageId":"restrictedSyntax","endLine":92,"endColumn":67,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"no-restricted-syntax","severity":2,"message":"Instantiate services via ServiceFactory.get*Service() factory functions instead of using 'new <Service>()'.","line":96,"column":51,"nodeType":"NewExpression","messageId":"restrictedSyntax","endLine":96,"endColumn":69,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"no-restricted-syntax","severity":2,"message":"Instantiate services via ServiceFactory.get*Service() factory functions instead of using 'new <Service>()'.","line":100,"column":52,"nodeType":"NewExpression","messageId":"restrictedSyntax","endLine":100,"endColumn":71,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"no-restricted-syntax","severity":2,"message":"Instantiate services via ServiceFactory.get*Service() factory functions instead of using 'new <Service>()'.","line":106,"column":13,"nodeType":"NewExpression","messageId":"restrictedSyntax","endLine":106,"endColumn":59,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"no-restricted-syntax","severity":2,"message":"Instantiate services via ServiceFactory.get*Service() factory functions instead of using 'new <Service>()'.","line":111,"column":54,"nodeType":"NewExpression","messageId":"restrictedSyntax","endLine":111,"endColumn":75,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"no-restricted-syntax","severity":2,"message":"Instantiate services via ServiceFactory.get*Service() factory functions instead of using 'new <Service>()'.","line":115,"column":51,"nodeType":"NewExpression","messageId":"restrictedSyntax","endLine":115,"endColumn":69,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"no-restricted-syntax","severity":2,"message":"Instantiate services via ServiceFactory.get*Service() factory functions instead of using 'new <Service>()'.","line":119,"column":52,"nodeType":"NewExpression","messageId":"restrictedSyntax","endLine":119,"endColumn":71,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\utils\\constants.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\utils\\env.ts","messages":[{"ruleId":"@typescript-eslint/no-deprecated","severity":2,"message":"`url` is deprecated. Use `z.url()` instead.","line":4,"column":73,"nodeType":"Identifier","messageId":"deprecatedWithReason","endLine":4,"endColumn":76}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { z } from 'zod';\r\n\r\nconst envSchema = z.object({\r\n  BASE_URL: z.string().default('http://localhost:3005').pipe(z.string().url()),\r\n  NODE_ENV: z\r\n    .enum(['development', 'production', 'test'])\r\n    .default('development'),\r\n  PORT: z.coerce.number().int().positive().default(3005),\r\n  USE_AUTH: z\r\n    .string()\r\n    .default('false')\r\n    .transform((value) => value === 'true'),\r\n});\r\n\r\nexport type Env = z.infer<typeof envSchema>;\r\n\r\nexport const env = envSchema.parse({\r\n  BASE_URL: process.env['BASE_URL'],\r\n  NODE_ENV: process.env['NODE_ENV'],\r\n  PORT: process.env['PORT'],\r\n  USE_AUTH: process.env['USE_AUTH'],\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\utils\\fileNameUtil.ts","messages":[{"ruleId":"no-control-regex","severity":2,"message":"Unexpected control character(s) in regular expression: \\x00, \\x1f.","line":2,"column":20,"nodeType":"Literal","messageId":"unexpected","endLine":2,"endColumn":43},{"ruleId":"security/detect-unsafe-regex","severity":2,"message":"Unsafe Regular Expression","line":4,"column":29,"nodeType":"Literal","endLine":4,"endColumn":70},{"ruleId":"regexp/prefer-named-capture-group","severity":1,"message":"Capture group '(con|prn|aux|nul|com\\d|lpt\\d)' should be converted to a named or non-capturing group.","line":4,"column":31,"nodeType":"Literal","messageId":"required","endLine":4,"endColumn":60},{"ruleId":"regexp/prefer-named-capture-group","severity":1,"message":"Capture group '(\\..*)' should be converted to a named or non-capturing group.","line":4,"column":60,"nodeType":"Literal","messageId":"required","endLine":4,"endColumn":66}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"const ILLEGAL_RE = /[/?<>\\\\:*|\"]/g;\r\nconst CONTROL_RE = /[\\x00-\\x1f\\x80-\\x9f]/g;\r\nconst RESERVED_RE = /^\\.+$/;\r\nconst WINDOWS_RESERVED_RE = /^(con|prn|aux|nul|com\\d|lpt\\d)(\\..*)?$/i;\r\nconst WINDOWS_TRAILING_RE = /[. ]+$/;\r\n\r\ntype Options = {\r\n  readonly replacement?: string;\r\n};\r\n\r\nconst sanitize = (input: string, replacement: string): string => {\r\n  if (typeof input !== 'string') {\r\n    throw new Error('Input must be string');\r\n  }\r\n\r\n  return input\r\n    .replace(ILLEGAL_RE, replacement)\r\n    .replace(CONTROL_RE, replacement)\r\n    .replace(RESERVED_RE, replacement)\r\n    .replace(WINDOWS_RESERVED_RE, replacement)\r\n    .replace(WINDOWS_TRAILING_RE, replacement);\r\n};\r\n\r\nexport const sanitizeFilePath = (input: string, options?: Options): string => {\r\n  const replacement = options?.replacement ?? '';\r\n  const output = sanitize(input, replacement);\r\n\r\n  if (replacement === '') {\r\n    return output;\r\n  }\r\n\r\n  return sanitize(output, '');\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\utils\\helperUtils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\utils\\logger.ts","messages":[{"ruleId":"@typescript-eslint/restrict-template-expressions","severity":2,"message":"Invalid type \"unknown\" of template literal expression.","line":62,"column":23,"nodeType":"MemberExpression","messageId":"invalidType","endLine":62,"endColumn":40},{"ruleId":"@typescript-eslint/restrict-template-expressions","severity":2,"message":"Invalid type \"unknown\" of template literal expression.","line":62,"column":60,"nodeType":"MemberExpression","messageId":"invalidType","endLine":62,"endColumn":72}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Logger utility for handling application logs.\r\n * @module Logger\r\n */\r\nimport winston from 'winston';\r\n\r\nimport { LOG_CONFIG } from './constants.js';\r\nimport { Environment } from './Environment.js';\r\n\r\ntype FileTransportOptions = {\r\n  readonly colorize: boolean;\r\n  readonly filename: string;\r\n  readonly handleExceptions: boolean;\r\n  readonly json: boolean;\r\n  readonly level: string;\r\n  readonly maxFiles: number;\r\n  readonly maxsize: number;\r\n  readonly timestamp: boolean;\r\n};\r\n\r\ntype ConsoleTransportOptions = {\r\n  readonly colorize: boolean;\r\n  readonly handleExceptions: boolean;\r\n  readonly json: boolean;\r\n  readonly level: string;\r\n  readonly timestamp: boolean;\r\n};\r\n\r\ntype LoggerOptions = {\r\n  readonly console: ConsoleTransportOptions;\r\n  readonly file: FileTransportOptions;\r\n};\r\n\r\nconst OPTIONS: LoggerOptions = {\r\n  console: {\r\n    colorize: true,\r\n    handleExceptions: true,\r\n    json: true,\r\n    level: 'debug',\r\n    timestamp: true,\r\n  },\r\n  file: {\r\n    colorize: false,\r\n    filename: 'local.log',\r\n    handleExceptions: true,\r\n    json: true,\r\n    level: 'info',\r\n    maxFiles: LOG_CONFIG.MAX_LOG_FILES,\r\n    maxsize: LOG_CONFIG.MAX_LOG_FILE_SIZE,\r\n    timestamp: true,\r\n  },\r\n};\r\n\r\nconst transports: winston.transport[] = [\r\n  new winston.transports.Console(OPTIONS.console),\r\n];\r\n\r\nconst format = Environment.isLocal()\r\n  ? winston.format.combine(\r\n      winston.format.timestamp({ format: 'YYYY/MM/DD HH:mm:ss' }),\r\n      winston.format.printf(\r\n        (info) => `[${info['timestamp']}] ${info.level}: ${info.message}`,\r\n      ),\r\n    )\r\n  : winston.format.json();\r\n\r\nif (Environment.isLocal()) {\r\n  transports.push(new winston.transports.File(OPTIONS.file));\r\n}\r\n\r\nexport const Logger = winston.createLogger({\r\n  exitOnError: false,\r\n  format,\r\n  level: Environment.isProduction() ? 'info' : 'debug',\r\n  transports,\r\n});\r\n\r\nLogger.on('error', (error: Error) => {\r\n  Logger.info('Logger caught an unhandled error', { error: error.message });\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\utils\\objectUtil.test.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: Declaration or statement expected.","line":294,"column":1966}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\r\n  cleanUpData,\r\n  getDefaultObject,\r\n  getNextId,\r\n  getNextIdFromPos,\r\n  removeEmptyAttributes,\r\n  sortObjectKeys,\r\n  trimAttributes,\r\n} from './objectUtil.js';\r\n\r\ndescribe('getDefaultObject', () => {\r\n  test('should return object with default values for each type', () => {\r\n    const obj = {\r\n      name: 'John',\r\n      age: 30,\r\n      active: true,\r\n      tags: ['tag1'],\r\n      meta: { key: 'value' },\r\n    };\r\n\r\n    const result = getDefaultObject(obj);\r\n\r\n    expect(result).toEqual({\r\n      name: '',\r\n      age: 0,\r\n      active: false,\r\n      tags: [],\r\n      meta: {},\r\n    });\r\n  });\r\n\r\n  test('should handle empty object', () => {\r\n    const result = getDefaultObject({});\r\n    expect(result).toEqual({});\r\n  });\r\n});\r\n\r\ndescribe('removeEmptyAttributes', () => {\r\n  test('should remove empty strings', () => {\r\n    const obj = {\r\n      name: 'John',\r\n      address: '',\r\n    };\r\n\r\n    const result = removeEmptyAttributes(obj);\r\n\r\n    expect(result).toEqual({\r\n      name: 'John',\r\n    });\r\n  });\r\n\r\n  test('should remove empty arrays', () => {\r\n    const obj = {\r\n      name: 'John',\r\n      hobbies: [],\r\n    };\r\n\r\n    const result = removeEmptyAttributes(obj);\r\n\r\n    expect(result).toEqual({\r\n      name: 'John',\r\n    });\r\n  });\r\n\r\n  test('should remove null values', () => {\r\n    const obj = {\r\n      name: 'John',\r\n      email: null,\r\n    };\r\n\r\n    const result = removeEmptyAttributes(obj);\r\n\r\n    expect(result).toEqual({\r\n      name: 'John',\r\n    });\r\n  });\r\n\r\n  test('should remove whitespace-only strings', () => {\r\n    const obj = {\r\n      name: 'John',\r\n      address: '   ',\r\n    };\r\n\r\n    const result = removeEmptyAttributes(obj);\r\n\r\n    expect(result).toEqual({\r\n      name: 'John',\r\n    });\r\n  });\r\n\r\n  test('should keep zero values', () => {\r\n    const obj = {\r\n      name: 'John',\r\n      age: 0,\r\n    };\r\n\r\n    const result = removeEmptyAttributes(obj);\r\n\r\n    expect(result).toEqual({\r\n      name: 'John',\r\n      age: 0,\r\n    });\r\n  });\r\n\r\n  test('should keep false values', () => {\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n});  });    expect(result).toEqual({ value: 1, index: 0 });    const result = getNextIdFromPos(items, 5);    const items = [{ id: 1 }, { id: 2 }];  test('should handle start position beyond array length', () => {  });    expect(result).toBeUndefined();    const result = getNextIdFromPos(undefined, 0);  test('should return undefined for undefined input', () => {  });    expect(result).toBeUndefined();    const result = getNextIdFromPos([], 0);  test('should return undefined for empty array', () => {  });    expect(result).toEqual({ value: 4, index: 0 });    const result = getNextIdFromPos(items, 1);    const items = [{ id: 1 }, { id: 2 }, { id: 3 }];  test('should return next id from specified position', () => {describe('getNextIdFromPos', () => {});  });    expect(result).toBe(2);    const result = getNextId(items);    const items = [{ id: 1 }];  test('should return 2 when only id 1 exists', () => {  });    expect(result).toBeUndefined();    const result = getNextId(undefined);  test('should return undefined for undefined input', () => {  });    expect(result).toBeUndefined();    const result = getNextId([]);  test('should return undefined for empty array', () => {  });    expect(result).toBe(4);    const result = getNextId(items);    const items = [{ id: 3 }, { id: 1 }, { id: 2 }];  test('should handle unsorted items', () => {  });    expect(result).toBe(2);    const result = getNextId(items);    const items = [{ id: 1 }, { id: 3 }, { id: 4 }];  test('should return first missing id in sequence', () => {  });    expect(result).toBe(4);    const result = getNextId(items);    const items = [{ id: 1 }, { id: 2 }, { id: 3 }];  test('should return next sequential id when all ids are contiguous', () => {describe('getNextId', () => {});  });    expect(result).toEqual({});    const result = cleanUpData({});  test('should handle empty object', () => {  });    expect(Object.keys(result)[0]).toBe('id');    const result = cleanUpData(data);    };      age: 30,      id: 1,      name: 'John',    const data = {  test('should move id to first position if present', () => {  });    });      name: 'John',      city: 'NYC',      age: 30,    expect(result).toEqual({    const result = cleanUpData(data);    };      city: 'NYC',      address: '   ',      age: 30,      name: '   John   ',    const data = {  test('should combine remove empty, trim, and sort operations', () => {describe('cleanUpData', () => {});  });    expect(result).toEqual({ name: 'John' });    const result = sortObjectKeys(obj);    const obj = { name: 'John' };  test('should handle single key', () => {  });    expect(result).toEqual({});    const result = sortObjectKeys({});  test('should handle empty object', () => {  });    });      c: 3,      b: 2,      a: 1,    expect(result).toEqual({    expect(Object.keys(result)).toEqual(['a', 'b', 'c']);    const result = sortObjectKeys(obj);    };      b: 2,      a: 1,      c: 3,    const obj = {  test('should sort keys alphabetically', () => {describe('sortObjectKeys', () => {});  });    });      tags: ['tag1', 'tag2'],      active: true,      age: 30,      name: 'John',    expect(result).toEqual({    const result = trimAttributes(obj);    };      tags: ['tag1', 'tag2'],      active: true,      age: 30,      name: 'John',    const obj = {  test('should not modify non-string values', () => {  });    });      age: 30,      name: '',    expect(result).toEqual({    const result = trimAttributes(obj);    };      age: 30,      name: '   ',    const obj = {  test('should trim whitespace-only strings to empty', () => {  });    });      age: 30,      name: 'John',    expect(result).toEqual({    const result = trimAttributes(obj);    };      age: 30,      name: '   John   ',    const obj = {  test('should trim string attributes', () => {describe('trimAttributes', () => {});  });    });      active: false,      name: 'John',    expect(result).toEqual({    const result = removeEmptyAttributes(obj);    };      active: false,      name: 'John',    const obj = {    expect(result).to","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\utils\\objectUtil.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\utils\\routerUtils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\utils\\test.ts","messages":[{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":8,"column":25,"nodeType":"MemberExpression","endLine":8,"endColumn":34},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":9,"column":25,"nodeType":"MemberExpression","endLine":9,"endColumn":34}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { VALIDATION_LIMITS } from './constants.js';\r\n\r\nexport const versionCompare = (version1: string, version2: string): number => {\r\n  const parts1 = version1.split('.');\r\n  const parts2 = version2.split('.');\r\n\r\n  for (let i = 0; i < VALIDATION_LIMITS.MAX_VERSION_PARTS; i++) {\r\n    const num1 = Number(parts1[i] ?? 0);\r\n    const num2 = Number(parts2[i] ?? 0);\r\n\r\n    if (num1 > num2) {\r\n      return 1;\r\n    }\r\n\r\n    if (num1 < num2) {\r\n      return -1;\r\n    }\r\n  }\r\n\r\n  return 0;\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jdumo\\Documents\\0Projects\\site8\\server1\\src\\utils\\zodHelper.ts","messages":[{"ruleId":"@typescript-eslint/no-deprecated","severity":2,"message":"`ZodFormattedError` is deprecated. Use `z.core.$ZodFormattedError` instead.","line":6,"column":28,"nodeType":"Identifier","messageId":"deprecatedWithReason","endLine":6,"endColumn":45},{"ruleId":"@typescript-eslint/no-deprecated","severity":2,"message":"`Schema` is deprecated. Use `z.ZodType`","line":11,"column":11,"nodeType":"Identifier","messageId":"deprecatedWithReason","endLine":11,"endColumn":17},{"ruleId":"@typescript-eslint/no-deprecated","severity":2,"message":"`format` is deprecated. Use the `z.treeifyError(err)` function instead.","line":20,"column":40,"nodeType":"Identifier","messageId":"deprecatedWithReason","endLine":20,"endColumn":46}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { Schema, ZodError, ZodFormattedError } from 'zod';\r\n\r\nexport type ParseResult<T> = {\r\n  readonly data: T | null;\r\n  readonly error: ZodError<T> | null;\r\n  readonly errorFormatted: ZodFormattedError<T> | null;\r\n  readonly success: boolean;\r\n};\r\n\r\nexport const safeParse = <T>(\r\n  schema: Schema<T>,\r\n  inputData: Partial<T>,\r\n): ParseResult<T> => {\r\n  const parsedData = schema.safeParse(inputData);\r\n\r\n  if (!parsedData.success) {\r\n    return {\r\n      data: null,\r\n      error: parsedData.error,\r\n      errorFormatted: parsedData.error.format(),\r\n      success: false,\r\n    };\r\n  }\r\n\r\n  return {\r\n    data: parsedData.data,\r\n    error: null,\r\n    errorFormatted: null,\r\n    success: true,\r\n  };\r\n};\r\n","usedDeprecatedRules":[]}]